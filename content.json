{"meta":{"title":"Miss Shen","subtitle":"","description":"","author":"YY Huang","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"VHDL第十章数字系统设计方法","slug":"VHDL第十章数字系统设计方法","date":"2023-02-18T02:19:48.000Z","updated":"2023-02-18T02:20:08.506Z","comments":true,"path":"2023/02/18/VHDL第十章数字系统设计方法/","link":"","permalink":"http://example.com/2023/02/18/VHDL%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/","excerpt":"","text":"数字系统的层次化结构可以分为四个层次： 性能级 功能级 结构级 物理级 系统设计：将性能级的说明映射为功能级的设计过程 逻辑设计：将功能级的描述转换为结构（逻辑）的过程 物理设计：将逻辑结构转换为物理级（电路）的实现采用自顶向下的设计方法 模块技术（系统设计）将系统总的功能分解为若干个子功能。划分系统的模块结构，需要考虑以下几个方面： 串行数据接收器#值得一看对应的课程（点击跳转） 性能级设计： 迭代技术简单的逻辑子网络代替复杂的组合逻辑网络，实现要求的处理功能。 时间迭代 空间迭代 两者混合 空间迭代网络的基本模型结构高度重复的组合逻辑网络。利用结构相同的子网络作为单元电路。 单元电路的输入： 来自外部的一次输入 来自串接链路前级的二次输入单元电路的输出： 输出到外部的一次输出 输出到串接链路次级的二次输出 二次输入和二次输出是建立子网络之间联系的纽带。 时间迭代网络的基本模型子网络在时钟控制下，接收来自信息寄存器A，．．．E通过移位的串行输入，在子网络内作串行处理后，串行输出到结果寄存器R1 ，…Rn 。 暂存单元C用于寄存子网络的二次输出，以便在时钟的下一个节拍作为子网络的二次输入参加运算和操作。暂存单元C对应空间迭代方式中的边界输入。 4位二进制加法器迭代网络设计分析：根据二进制数相加的运算规则可知，任意一位的和Si等于被加数 Ai、Bi及来自低位的进位Ci－1，而其进位Ci则为相加后的溢出值。实现1：根据这个结构特性，选用全加器FA作为子网络的单元电路，以低 位向高位的进位值作为子网络的二次输入&#x2F;输出，通过空间迭代法构 成的四位并行加法器如下图。通常最低位的进位输入Cin置为0，而 最高位的Cout作为溢出标志。一个空间，一个时间迭代 二维迭代技术 乘法器设计 性能级四位数字乘法器 结构级设计 空间迭代：时间迭代——部分积左移累加算法 部分和右移与部分积累加算法 总结","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第九章设计与优化","slug":"VHDL第九章设计与优化","date":"2023-02-18T02:18:11.000Z","updated":"2023-02-18T02:18:59.458Z","comments":true,"path":"2023/02/18/VHDL第九章设计与优化/","link":"","permalink":"http://example.com/2023/02/18/VHDL%E7%AC%AC%E4%B9%9D%E7%AB%A0%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/","excerpt":"","text":"重要思想：先设计模块电路后设计代码，设计者须明确每一段代码生成的电路，否则优化无从谈起。 以设计全加器为例逻辑函数： Si&#x3D;Ai⊕Bi⊕Ci-1 Ci&#x3D;AiBi+Ci-1(Ai⊕Bi) 12345tmp &lt;= Ai xor Bi ;Si &lt;= tmp xor Ci-1 ;Ci &lt;= (Ai and Bi) or (Ci-1 and tmp) ; 当上述设计的全加器，若Ci和Si做同或运算波形存在竞争与冒险： Si&#x3D;Ai⊕Bi⊕Ci-1 将：Ci&#x3D;AiBi+Ci-1(Ai⊕Bi) 改为： Ci&#x3D;AiBi + BiCi-1 + AiCi-1 123Si &lt;= Ai xor Bi xor Ci-1； Ci &lt;=（Ai and Bi）or（Bi and Ci-1）or（Ai and Ci-1）； 严格来说，vhdl代码不是程序。VHDL既称为硬件描述语言，则VHDL主要用于设计描述硬线电路以及对设计的抽象仿真。那么，对于一个数字系统设计者来说，能够将所设计的代码映射为相应的硬线电路是必须具备的能力。 寄存器的引入方法触发器的引入两种引入方法：都是条件涵盖不完整的语句 条件涵盖不完整的if语句会产生触发器 条件涵盖不完整的case语句会产生触发器 123456789101112131415161718192021222324252627282930313233343536ENTITY DFF ISPORT(clk:in std_logic; y:out std_logic);END DFF;ARCHITECTURE BEHAV OF DFF ISBEGIN--------------------------------------------------PROCESS(clk)BEGIN IF (clk’event AND clk=‘1’) THEN y&lt;=a; END IF;END PROCESS;---------------------------------------------------PROCESS(clk) BEGIN IF (rising_edge(clk)) THEN y&lt;=a; END IF;END PROCESS;-- 此时的clk必须是std_logic类型---------------------------------------------------PROCESSBEGIN WAIT UNTIL clk’evnt ANDclk=‘1’; y&lt;=a;END PROCESS;--： Wait语句必须放在进程的首部或尾部，并且一个进程中的wait语句不能超过一个---------------------------------------------------PROCESS(clk)BEGIN IF clk=‘1’ THEN y&lt;=a; END IF;END PROCESS;-- 因为要启动进程必须要clk发生跳变，且仅当clk=‘1’时赋值才有效。所以综合后是一个D触发器 上面的是使用条件涵盖不完整的if语句形成触发器，当if语句涵盖完整时，综合后形成一般的组合逻辑。 当if 语句条件涵盖完整时，产生一个2选1的多路选择器。12345678910111213PROCESS( state, inA, inB) BEGIN CASE state IS WHEN s0 =&gt; outA&lt;=‘1’; --没有对outB赋值，所以outB保持原值 WHEN s1 =&gt; outA&lt;=inB ; outB&lt;=‘1’; WHEN s2 =&gt; outB&lt;=inA; --没有对outA赋值，所以outA保持原值 END CASE;END PROCESS; 锁存器的引入 条件涵盖不完整的if语句会产生锁存器 case语句中条件不完全覆盖会产生锁存器实例：12345678910111213141516171819202122232425262728293031ENTITY rigister IS PORT(a,clk:in std_logic; y:out std_logic);END DFF;ARCHITECTURE BEHAV OF rigister ISBEGIN----------------------------------------------PROCESS(clk,a) BEGIN IF clk=‘1’ THEN y&lt;=a; ELSE --VHDL默认保持先前的值，故引入高电平锁存器 END IF; END PROCESS;-----------------------------------------------PROCESS(clk,a) BEGIN IF clk=‘1’ THEN y&lt;=a; --省去了ELSE分支，表示分支y值不发生跳变，同样引入高电平锁存器 END IF; END PROCESS;-----------------------------------------------PROCESS(clk,a) BEGIN IF clk=‘0’ THEN --引入低电平锁存器 y&lt;=a; END IF;END PROCESS; case语句 1234567891011121314151617ENTITY rigister IS PORT(a,b:in std_logic; sel:in std_logic_vector(1 downto 0); y:out std_logic);END DFF;ARCHITECTURE BEHAV OF rigister ISBEGIN------------------------------------PROCESS(sel,a,b) BEGIN CASE sel IS WHEN “00” =&gt; y&lt;=a; WHEN “01” =&gt; y&lt;=a; WHEN OTHERS =&gt; NULL; END CASE;END PROCESS; 触发器和锁存器的区别#值得一看process中启动条件在触发器中只有clk在锁存器中有 clk 和其他信号，持续的时间，仔细看图 需要注意的问题例1 在MAXPLUS中，一个进程中只能引入一个边沿检测的语句。在QUARTUS中便不会有这种错误。 例2将用于产生寄存器的信号或变量赋值语句放在了ELSE条件分支上。 这种赋值方式相当于检测如果没有时钟信号，则赋新值。不可能有这样的硬件电路与之对应。 例3 例4 12if not ( clock’event and clock=‘1’) then --错误 原因：将边沿表达式当成了操作数 注意的点 在引入寄存器时，一般情况下采用异步复位的方式 寄存器中，复位的优先级一般要高于置位 在引入时钟具有使能作用的寄存器时，宜采用嵌套的if语句来描述 注意将时序进程和组合进程分开描述 具有时钟门控的触发器引入：改为如下这种 同步复位&#x2F;置位功能引入： 123456789101112process(clk)begin if clk’event and clk=‘1’ then if set=‘1’ then y&lt;=‘1’; --注意，输入‘1’（或true）才能引入硬件置位功能 else y&lt;=a and b; end if ; end if;end process; 上面这个为置1 12345678910process(clk，reset，set)begin if reset=‘1’then y&lt;=‘0’; --必须是一个常量值0才能引入硬件复位机制 elsif set=‘1’then y&lt;=‘1’; --必须是一个常量值1才能引入硬件置位机制 elsif rising_edge(clk) then y&lt;=a and b; end if ;end process; 复位的优先级比置位高，这是符合常规硬件电路结构的。 避免不必要寄存器的引入由于综合在硬件电路中需要一定的空间，为了更快的工作，需要避免不必要的寄存器的引入#值得一看 组合逻辑电路中不能存在边沿触发状态 IF 语句，CASE语句涵盖需要完整。 如果信号或变量在一个CASE分支有赋值，就必须在每个分支都有赋值操作(或者在CASE语句前面有赋值)。 实例：1、在每个case分支都对outA和outB赋值；2、在case语句前面，先对outA和outB赋初值； 见课本p113-p117(《VHDL数字系统设计》徐向民主编) 分析基于3位二进制计数器的3个逻辑输出 1234567891011121314151617181920212223library ieee;use ieee.std_logic_1164.all;use ieee.std_logic_unsigned.all;entity exmp is port ( clock, reset : in std_logic ; and_b, or_b, xor_b : out std_logic) ;end exmp;architecture rtl of exmp isbegin process variable count: std_logic_vector(2 downto 0); begin wait until clock’event and clock=‘1’; if reset=‘1’ then count :=“000”; else count :=count+1; end if; and_b&lt;=count(2) and count(1) and count(0); or_b&lt;=count(2) or count(1) or count(0); xor_b&lt;=count(2) xor count(1) xor count(0); end process;end rtl; 综合后的电路结构如图 结果：引入了6个D触发器，但输出只依赖于count的计数。由于count作为累加器，已具有存储功能，3个输出变量没有必要利用别的寄存器另加存储。上述例题的问题在于将3个输出赋值语句放在了同一个具有wait语句的进中。 改进：可将这3个输出赋值语句放在另外一个没有wait或if语句的进程中。使用两个进程，一个进程具有Wait语句，用于产生具有寄存器性质的计数器，另一个只作输出赋值用（双进程）综合后的电路结构： 设计与优化的重要概念（之前的内容也有涉及到：同步时序电路设计）![[第五章 状态机设计#时钟周期的选取]] 建立时间：指在触发器的时钟信号上升沿到来以前，数据稳定不变的时间。如果 建立时间不够，数据将不能正确输入触发器。 保持时间：指在触发器的时钟信号上升沿到来以后，数据稳定不变的时间。如果 保持时间不够，数据同样不能正确输入触发器。 传播时延：信号传播路径上所需要的时间 时钟偏差：一个时钟翻转的到达时间在空间上的差别通常称为时钟偏差。 时钟抖动：指在芯片的某一个定点上时钟周期发生暂时的变化影响： 习题初步设计： 123456789101112131415161718pulse:process(rst_n,pulse) begin if(rst_n=‘0’) then counter &lt;= (others=&gt;’0’); elsif(pulse ‘event and pulse = ‘1’) counter &lt;= counter + 1; end if; end process;cs:process(rst_n,cs_n) begin if(rst_n=‘0’) then dout &lt;= 0; elsif(cs_n ‘event and cs_n = ‘0’) dout &lt;= counter; end if; end procss; ---- 不同步，当同时出现 一个上升，一个下降呢？ 但是当脉冲信号PULSE和读片选信号CS_N是异步信号,PULSE何时出现上升沿和CS_N何时出现下降沿是不可控。若两者同时出现，结果并不唯一。 How to solve?使用跨时钟域的同步设计，将PULSE和CS_N同步于时钟。 12345678910111213141516171819en1:process(clk,rst_n,pulse) begin if(rst_n = ‘0’) then preg1 &lt;= ‘1’; preg2 &lt;= ‘1’; elsif(clk ‘event and clk=‘1’) preg1 &lt;= pulse; preg2 &lt;= preg1; end if; pos_en &lt;= NOT preg2 AND preg1; end process;en1:process(clk,rst_n,cs_n) begin if(rst_n = ‘0’) then preg1CS &lt;= ‘1’; preg2CS&lt;= ‘1’; elsif(clk ‘event and clk=‘1’) preg1CS &lt;=cs_n; preg2CS &lt;= preg1CS ; end if; PosCS_en &lt;= NOT preg1CS AND preg2CS; end process; 跨时钟域信号处理如图： 若不规范，将可能得到亚稳态数据。What is it?如果数据输入不满足建立时间和保持时间,那么触发器的晶体管就不能被可靠地设置成代表逻辑0或逻辑1的电压。不是确定在高或低电平就是被设到有效水平之前，晶体管就可能停留在一个中间电压，这就叫亚稳态。 如何进行跨时钟域的信号传输 同步寄存器链 时钟同步设计 专用握手信号 借助存储器（FIFO结构） 相位控制 分割同步模块 专用握手信号（有点类似于三次握手，四次挥手）使用专用控制信号进行状态指示，（req和ack）分别脉冲检测方法进行同步。详细如下： 优点： 可以接受到的数据稳定可靠，避免亚稳态缺点： 消耗时间，不适合高速传输。 借助存储器（FIFO结构） 重要参数： 相位控制如果其中至少一个时钟是在FPGA中内部通过PLL（锁相环）或DLL（延迟锁相环）可控制的，另一个时钟与在PLL或DLL解决方案中那个时钟周期有倍数关系，那么可采用相位匹配来消除冲突。 分割同步模块每个基本模块的时序分析变为一致，因为它是完全同步。时序在其应用到整个同步模块时很容易确定。","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第八章可综合性","slug":"VHDL第八章可综合性","date":"2023-02-18T02:17:49.000Z","updated":"2023-02-18T02:18:37.929Z","comments":true,"path":"2023/02/18/VHDL第八章可综合性/","link":"","permalink":"http://example.com/2023/02/18/VHDL%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%8F%AF%E7%BB%BC%E5%90%88%E6%80%A7/","excerpt":"","text":"VHDL 语言结构向硬件的映射有效的VHDL建模风格是控制综合结果最为有力的手段。不同综合工具对于同样的硬件描述，会得到不同的综合结果。 VHDL中并不是将所有语句综合，综合的是其中的一部分语句。 延时描述（after 语句、wait for语句）将被忽略而综合时间约束则在综合过程中通过综合命令输入。 支持有限类型有些类型不具备硬件对应物，不可能被综合，如文件类型。通常可综合类型包括位、位矢量、布尔量、整数、枚举类型、数组等。其余像浮点数类型、记录类型等只能得到有限支持，而时间类型等完全不能被综合 进程的书写要服从一定的限制在仿真时，VHDL进程可以任意书写。而在综合时，通常要求一个进程内只能有一个有效时钟，有的工具还有进一步的限制 可综合代码应该是同步式的设计推荐使用同步，当然也能使用异步设计，但往往需要进一步的优化或调整。 VHDL类型VHDL中包括的对象有： 常量（constant）、信号（signal）、变量（variable），都必须定义为某种具体的类型。 可综合数据类型 面向综合的建模都支持这样一些类型：枚举类型、整数、一维数组。比较先进的综合工具现在一般也可以处理二维数组和简单的记录类型。 （1）枚举类型 枚举类型通过列出所有可能的取值来定义，例如： type Boolean is (FALSE , TRUE); type State_type is (HALT,READY,RUN,ERROR); type Std_ulogic is (‘U’,‘X’,‘0’, ‘1’, ‘Z’, ‘-’); 以上Std_ulogic的定义实际是对‘0’‘1’等字符进行了重载，由于这个定义已经成为IEEE标准，因此综合时不会产生额外硬件。而对于抽象层次更高的Boolean和 State_type则需要进行状态编码。 一般来说，状态编码是把状态值编码为位矢量（如bit_vector），矢量长度是能够表示所有状态的最短位宽。 例如，State_type的4个状态值可以分别校编码为“00”，“01”，“10”和“11”。 （2）整数类型 可综合的整数类型定义总是有界的，例如： type My_integer is Integer range 0 to 255; subtype Byte_int is Integer range -128 to 127; 对整数类型进行综合时，综合工具首先将其翻译为位矢量，矢量长度仍取能够满足需要的最短位宽。 建议类型定义时明确指出整数的范围，以便于综合工具进行优化。否则大部分综合工具按32位处理。 综合后的电路中，整数以矢量形式出现，但通常只能以整个矢量为单位访问，即不能单独访问每一位。 （3）数组类型 现在的综合工具都能够处理一维数组，例如： type Word is arry （31 downto 0) of Bit; type My_RAM is array (1023 downto 0 ) of Word; 对于Word类型，综合工具通常将其综合为总线。 My_RAM类型实际是二维的，这种用两个一维数组代替一个两维数组是常用的综合建模技巧。现在先进的综合工具如synospys DC可以将其综合为RAM，一般的综合工具至少可以把它综合为寄存器 （4）记录类型 记录类型在定义复杂数据类型时非常方便，能够把不同数据类型的数据组织在一起统一访问。 但是，EDA工业界对综合工具是否应该支持记录类型还没有统一意见，因此大多数综合工具不提供这种能力或只能把组合了简单数据类型的记录进行综合。 可综合子集 ieee颁发的std_logic_1164，其中定义了9值数据类型 std_ulogic ieee颁布的标准 该项标准主要支持以下类型的综合：a) bit , boolean , bit_vectorb) character , stringc) integerd) std_logic , std_ulogic_vector , std_logic , std_logic_vectore) signed , unsignd VHDL的对象常量 变量 信号 常量常量只被计算一次，通过常量引导综合器获得优化结果 用于真值表、ROM等，或者用于信号赋值，在综合时会形成相应的硬件 作为算数运算的一个操作数出现，会有特定的优化措施，与硬件不会意义对应。 常量在作为条件表达式的一部分时综合工具会对整个语法结构进行布尔优化。 常量传播。在下面的VHDL代码中，由于数组ROM和ROM（5）的索引都是常量，因此WORD4实际上也成为常数，在进一步优化中，WORD4将作为常量被处理。这就是常量传播。 constant ROM : ROM_TYPE := Read(“Rom_file.dat”); signal WORD4 : Bit_vector (3 downto 0); begin WORD4 &lt;= ROM(5) 变量和信号两者有不同的仿真行为，在综合过程中，会产生不同的结果 一般来说，尽量使用变量能够获得比较好的综合结果，因为这样做使得优化的余地较大。但要注意，并不是所有的综合工具都支持变量的综合。 使用信号可以较好地保持综合前后在I&#x2F;O上的一致性（这时把进程内对信号的读写统称为I&#x2F;O），而且在需要锁存中间结果的时候，经常有必要使用信号 初值存在三种初值：由类型或子类型定义可以得到的默认初值，定义对象时明确指定的初值和进程入口处显示地赋予对象的初值。 以上三种初值的前两种只在仿真时有意义,在综合时将被忽略。 第三种形式将被综合器处理，形成对应电路 在进程入口处显示地赋予对象的初值。 运算符 逻辑运算符逻辑运算符包括二元逻辑运算符以及NOT运算，操作数可以是bit 和std_logic等类型的标量或同长度的矢量对象，也可以是 boolean类型的对象。这些运算符综合时直接调用逻辑门单元实现即可，但优化过后，可能被合并或改变 关系运算符没有统一的方法，利用被比较数的特点进行特定优化 一元算数运算符一元算术运算符有三个，即 **** +（正），一（负）和abs（取绝对值）。*对前两个运算符，综合工具大都可以用组合逻辑线路实现，如下的例子。abs运算符的处理比较复杂，大部分综合工具尚不能提供支持。 二元算术运算符特别是高层次综合工具,都能直接把加,减,乘运算综合为相应的电路,部分工具也支持除法运算。mod 和rem运算符通常不被综合工具支持。 顺序语句 if语句 (1)if语句包含了条件所有可能的取值,称之为完全if语句。这时综合器用多路选择器或基本逻辑门的组合来实现电路。用多路选择器实现电路时，if…elsif…else中隐含的优先关系会被消去。 (2)if语句条件未包含所有可能出现的情况,称之为不完全if语句此时有效条件是对某信号的跳变进行检测，并且在条件满足时是对信号进行赋值操作，那么会生成触发器。如果赋值号右边为一复杂表达式，则综合器先用组合逻辑电路计算表达式，计算结果送入触发器的数据输入。 case语句case语句与多路选择器电路的对应关系是显而易见的，但是，建模时要注意否则会造成电路的复杂化，甚至导致形成时序电路。 when others &#x3D;&gt; null;3. 循环语句 VHDL的循环语句有三种：for循环 、while循环,和无限loop…end loop。 有next语句和exit来配合循环语句使用。 并行语句包括进程、并行赋值语句、块语句、生成语句等。 进程 进程是VHDL中描述硬件行为最为有力的方式。进程内的语句属于顺序语句，而进程本身则属于并行语句。 综合后的电路存在寄存器，则是时序电路。 还存在两种情况： 2. 信号赋值语句 信号赋值语句的处理是直截了当的，下面: 语句1被综合成一要硬连线； 对于语句2，R将被当作常数处理； 语句3被综合为组合逻辑电路。 当然语句1和语句3经过逻辑优化后，可能改变形式或者被消去。 (1) S &lt;= A; (2) R&lt;= ‘1’; (3) T &lt;= (B xor C) or (D and E) or (F xnor G); 条件和选择赋值VHDL的并行语句有两种方式进行有条件的赋值，即条件赋值when…else 和选择赋值with…select…when。实际上，这两种语法结构都可以改写为等价的顺序语句。 元件例化语句 块语句","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第七章综合","slug":"VHDL第七章综合","date":"2023-02-16T16:57:48.000Z","updated":"2023-02-16T16:58:25.319Z","comments":true,"path":"2023/02/17/VHDL第七章综合/","link":"","permalink":"http://example.com/2023/02/17/VHDL%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%BB%BC%E5%90%88/","excerpt":"","text":"综合的层次针对一个给定的设计，根据设计应实现的功能与相应的约束条件，通过计算机的优化处理，获得一个满足要求的设计方案，这个过程就称为 综合。 其中综合具有多个层次，从高到低可以分为 算法层 寄存器传输层 逻辑层 电路层 版图层 三个大的层次：高层次综合、逻辑综合、版图综合 高层次综合从算法级的行为描述到 寄存器传输级的描述输入：硬件描述语言的源描述 综合结果：一般包括一个 数据通路和一个控制器。 数据通路（datapath）: 由寄存器、功能单元、多路器和总线等模块构成对的互连网络，实现数据的传输。 控制器（controller）: 通常由硬连逻辑（hardwired logic）或固件（firmware）构成，用于控制数据通路中数据的传输。 作用： 可以明显地提高设计速度，缩短设计周期，允许设计者寻求最优或满意的设计方案 可以直接进行数字系统从行为描述到芯片描述的设计工作。 （） 逻辑综合高抽象层次的描述自动地转换成较低抽象层次描述的一种方法。将RTL级的描述转换成门级网表的过程。如图 约束条件对于数字系统而言，芯片的面积和芯片的速度是综合时最主要考虑 约束的表示： 用于综合的约束可以用用户定义属性来表示。用户定义只是用于给综合工具传递约束信息，仿真时被忽略 123456789101112 attribute 属性名 ： 数据类型 ； attribute 属性名 of 对象名 ：对象类型 is 值--------------------------------------- Type state is ( s0, s1, s2, s3 ); Attribute enum_encoding of state : type is “00 01 11 10”; --用于确定状态编码，用于有限状态机的描述中----------------------------------------- Attribute pin_no :natural ; Attribute pin_no of q : signal is 42 ; --为端口锁定芯片引脚 资源的约束 1234if select=‘1’ then q&lt;=a+b; else q&lt;=c+d; end if ; 可以用2个加法器和1个二路选择器实现也可以用1个加法器和2个二路选择器完成。 时间的约束 假定一个时序系统工作在20MHZ的时钟频率，那么通过状态寄存器和此态产生逻辑的最大延迟不能超过50ns（20MHZ的倒数） 属性 （好像不太重要）用于规定设计所进行的环境，如用属性规定对输出器件必须驱动的负载、驱动设计时器件的驱动能力和输入信号的时序等。 负载属性 驱动属性![[Pasted image 20230217004524.png]] 到达时间 工艺库多数综合工具都有计算FPGA单元的十分完整的复杂延时模型，它包括固有的上升和下降时间、输出负载与输入级波形斜度延时和估计的引线延时，下图从门输入到输出的总延时是： 固有延时＋负载延时＋引线延时＋输入级波形斜度延时 RTL描述代码又被称为 数据流描述是一种明确规定寄存器描述的方法。即，是指以规定设计中采用的各种寄存器形式为特征，然后在寄存器之间插入组合逻辑。 逻辑综合器从 RTL 转换到 门级描述 有3个步骤： 把RTL描述转换为未优化的门级布尔描述； 执行布尔优化算法，产生一个优化的布尔方程描述； 按目的工艺要求，采用相应的工艺库把优化的布尔等式描述映射到实际逻辑门。 转换 从RTL描述转换到布尔等式描述通常并不是由用户控制的，所产生的中介形式一般为特定优化工具的格式，甚至是不可能由用户可视的。 按照这种中介描述，ALL IF、CASE、LOOP语句、条件信号赋值和选择信号赋值语句转换到它们的布尔表达式，或者由装配组成触发器和锁存器,或者由推论去生成触发器和锁存器。 按照其中介的描述这两种情况都能产生同样的触发器和锁存器 布尔优化 优化过程用大量的算法和规则把一个非优化的布尔的描述转化到优化的布尔描述。 转换非优化布尔描述到最低级描述，然后优化那种描述，并尝试用（引入中间变量）共享公共项去减少逻辑门。 包括展平设计和提取公因数 展平设计转换非优化布尔描述到一种pla格式的过程称为展平设计，即它将所有的逻辑关系都转换成简单的AND和OR的表达式。 目的：使非优化的布尔描述格式转换成能执行优化算法的布尔描述格式。 提取公因数提取公因数是把附加的中间项加到结构描述中的一种过程。展平设计通常会使设计变得非常之大，而且要产生大扇出，展平过程可能比提取公因数的设计在速度上要慢得多 映射到门级 映射过程取出由优化后的布尔描述并利用从工艺库得到的逻辑和定时信息生成网表。 网表是对用户所需面积和速度目标的体现，有大量的网表，它们在功能上相同但在速度和面积上都在一个很宽的范围上可变 示例： HDL逻辑综合软件 这类软件将把HDL语言翻译成最基本的与或非门的连接关系（网表），输出edf文件，导给PLD&#x2F;FPGA厂家的软件进行试配和布线。 ，在进行复杂HDL设计时，基本上都会使用一些专业的逻辑综合软件，而不使用PLD&#x2F;FPGA厂家的集成开发软件中自带的逻辑综合功能。","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第六章仿真","slug":"VHDL第六章仿真","date":"2023-02-16T12:53:34.000Z","updated":"2023-02-16T12:54:04.749Z","comments":true,"path":"2023/02/16/VHDL第六章仿真/","link":"","permalink":"http://example.com/2023/02/16/VHDL%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BB%BF%E7%9C%9F/","excerpt":"","text":"啥是仿真： 对设计的硬件描述和设计结果 通过计算级查错、验证的过程仿真（模拟） 从电路的描述（语言描述或图形描述）抽象出模型，然后将外部激励信号或数据施加于此模型，通过观察该模型在外部激励下的反应来判断该电路系统是否实现预期的功能。 目的 检查原始描述的正确性； 检查设计结果在逻辑功能和时序上的正确性； 检查设计结果中不含违反设计规则的错误。 级别 高层次仿真： 对系统的抽象行为算法或混合描述的电路进行的仿真。仿真的重点是系统功能和系统内部运算过程。 RTL级仿真 ：对基于RTL方法描述的电路进行的仿真。重点是仿真数据在系统内元件之间的流动关系。 逻辑仿真：对基于门、触发器、和功能块构成的系统进行的仿真。其方法是通过对电路施加激励，观察电路对激励的响应来判断电路的功能是否正确。检查其逻辑功能、延迟特性和负载特性等。 电路级仿真：对基于晶体管、电阻、电容等构成的电路进行的仿真。其方法是通过求解电路方程而得出电路电压和电流，从而求出电路输出波形的一种模拟（如PSPICE）。特点：仿真时间长、精度高。 开关级仿真：介于电路级和逻辑级之间的模拟。将电阻、电容不当作一个元件而当作晶体管和节点的参数来处理的一种模拟方法。其复杂度和仿真时间介乎于电路级与逻辑级之间。 仿真（模拟）的级别 逻辑模拟模型电路模型 电路网表： 逻辑电路是元件的集合。 指描述电路拓扑关系的一种数据结构。如果指定了每个元件各端口所连接的信号，就可以唯一确定电路的连接关系。每个元件有其元件模型。 一个元件E的描述包含有元件名N、模型M、输入端信号PI和输出端信号PO四部分。即 E&#x3D;（N，M，PI，PO） 元件N 模型M 输入信号PI 输出信号PO 以一位加法器的网表为例 负载表在仿真时需要频繁查找每个信号后所连接的元件，称为负载元件还是以上面的图为例 X信号后面接的是 E1、E3Y 信号后面的是： E1、 E3同理可得到所有的负载：CIN： E2，E4； S1： E2，E4； S2： E5； S3： E5； SUM： Ø；COUT： Ø 元件模型门的模型 功能、参数、扇入、扇出、延迟时间功能块的模型 功能和行为描述，不关系其内部结构和组成 信号模型二值模型、三值模型、四值模型、五值、九值 信号值强度表示 信号的驱动能力强制级F：信号连接电源或地，或者是一些输入激励；电阻级R：信号通过一较大的电阻与电源或地相连；高阻级Z：信号与电源和地相隔离 九值模型逻辑电平：0、1、未知X强度：强制F、弱W、高阻Z、未定U和无关-每个值为逻辑电平与强度的组合，其中高阻、未定和无关只有一个电平值（未知） 延迟模型1. 元件延迟 零延迟模型：理想元件； 单位延迟模型：所有元件延迟时间相同，单位为1个时间单位； 标准延迟模型： 对每种元件设定一个标准延迟时间，不考虑元件的离散性； 上升下降延迟模型：分别考虑上升下降延迟时间；模糊延迟模型：给出元件的最大最小延迟时间； 2. 惯性延迟与传输延迟 惯性延迟： 输入脉冲信号能在得到相应所需最小脉冲宽度 传输延迟： 信号通过元件和连线传输过程中所引起的延迟 前者在VHDL语句中，不做说明的一定是惯性延迟。当信号脉冲宽度小于器件的固有延时时，器件将不对输入信号作出任何反应。 Z &lt;= X;(惯性延时缺省) Z &lt;&#x3D; X AFTER 3 ns;（ 3ns的惯性延时）&#96; 后者 (TRANSPORT)传输延时常用于描述总线延时、连线延时及ASIC芯片中的路径延时。输出端信号在经过传输延时后，将完全复现输入端的波形&#96;Z &lt;&#x3D; TRANSPORT X AFTER delay; (只有传输延时) 思考题：Vo &lt;= Vi AFTER 4ns; 1 ) 有脉冲输出2 ）无3 ）有 延迟为4ns4 ) 有传播延迟，所以不考虑惯性延迟有脉冲输出（不管多小） 仿真过程 搭建好电路并进行编译。 将编译好后形成的网表放入数据库中。 产生波形文件。当仿真启动后，将读取数据库文件，生成模拟驱动程序，连同波形文件，输出结果。","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第五章状态机的设计","slug":"VHDL第五章状态机的设计","date":"2023-02-16T07:55:39.000Z","updated":"2023-02-16T07:56:11.512Z","comments":true,"path":"2023/02/16/VHDL第五章状态机的设计/","link":"","permalink":"http://example.com/2023/02/16/VHDL%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"时序电路 &#x3D; 组合逻辑+存储电路 三位计数器从000到111，循环往复以上升沿触发的D触发器作为状态寄存器次态和现态的真值表 又因为计数器需要使用到3个状态寄存器（即是3个状态寄存器）通过卡诺图的推导（次态方程出错）根据次态方程画出详细的电路 时序电路与状态机 状态机的本质 具有逻辑顺序或时序规律事件的一种描述方法。具有逻辑顺序和时序规律的事件都适合用状态机描述同步时序逻辑电路符合状态机的一般特征。 便可以使用状态机来描述 三个基本要素： 状态 ：状态变量 输出：某一个状态时特定发生的事件 输入： 进入状态的条件 电路的竞争与冒险竞争：多径信号汇合在一路，时间上有先有后。（殊途同归）冒险： 因为竞争导致电路输出错误的现象。 组合逻辑电路存在该问题，所以时序逻辑电路也一样面临着这个问题使用同步时序逻辑电路可以克服次态逻辑的上述问题 课本上消除竞争与冒险的方法： 考虑接入滤波电容 （简单但影响输出） 修改逻辑设计（电路往往十分复杂） 引入脉冲（对信号的时钟周期有所限制） 时钟周期的选取在时序电路中，存在 3个重要的时序参数$$建立时间t_{su}、保持时间t_{hold}、传播时延t_{c-q}$$ $t_{su}$ 建立时间： 触发器的时钟信号上升沿到达之前，数据稳定的时间$t_{hold}$ 数据输入触发器所需的时间$t_{c-q}$ 信号传播路径上传播所需要的时间 在同步时序电路中，假设电路其中一级最长的延时为$t_{plogic}$综上所述：$$时钟周期T 应该满足————T&gt; t_{su}+t_{c-q} + t_{plogic}$$#值得一看 有限状态机的描述方法ASM图（Algorithmic State Machine）其中蕴含着时序的关系，类似流程图。 ASM图的组成部分 状态框： 使用矩形框来表示状态 ， 状态名写在左上角，二进制编码写在右上角 ，操作内容写在方框内，该状态经历的时间至少为一个时钟周期。 判断框 棱形框表示 内部是条件，分支需要写明相应条件 条件框： 椭圆框表示 条件框必定与 判断框相连仅当判断框中判断变量满足相应的转移条件时，才进行条件框中标明的操作和信号输出 跟状态框有相似 但也有很大差别 状态单元 单个条件框 或者状态框组成 每一个状态单元表示一个时钟周期下 系统的状态 交通灯ASM图解答： 有限状态机的分类信号输出 ： Mealy （与当前状态有关，还与外部输入有关，首尾相连） Moore（仅与当前状态有关）结构： 单进程 双进程 三进程表达方式：符号化 状态机、确定状态编码状态机（顺序编码、onehot编码 格雷码状态机） 使用的判断条件: Moore型的输出与当前的输入部分无关，所以当前输出产生的人和效果将会延迟到下一个时钟周期 最大优点：将输入部分和输出部分隔离 Mealy 型，输出是输入的函数，所以当输入信号改变时，输出将在一个时钟周期内发生改变 单进程描述：它就是将状态机的三个逻辑单元（状态寄存器、下状态产生逻辑、输出逻辑）合并起来，采用一个进程描述 单进程状态机 还是以交通灯为例 123456789101112131415161718192021222324252627282930313233LIBRARY IEEE ;USE IEEE.STD_LOGIC_1164.ALL ;ENTITY traffic IS PORT( clock , timed , car : IN std_ulogic ; start_timer, major_green, minor_green : OUT std_ulogic );END ENTITY traffic ;ARCHITECTURE asm1 OF traffic IS BEGIN PROCESS （clock, timed, car) TYPE state_type IS (G, R); --这里采用符号化状态机的描述方式 VARIABLE state: state_type; --将状态定义为变量类型 BEGIN IF (rising_edge(clock)) THEN CASE state IS WHEN G =&gt; major_green &lt;= ‘1’; minor_green &lt;= ‘0’; IF (car = ‘1’) THEN start_timer &lt;= ‘ 1’; state := R; END IF; WHEN R =&gt; major_green &lt;= ‘0’; minor_green &lt;= ‘1’; IF (timed= ‘1’) THEN start_timer &lt;= ‘ 1’; state := G; END IF; END CASE; END IF END PROCESS;END ARCHITETURE; 单进程状态变量可以定义为变量类型，放在进程的说明部分 进程开头有时钟有效边沿的检测语句 注意在这里进程敏感参数表中的car和timed可省去rising_edge(clock)也可以写成clock’event and clock&#x3D;‘1’ if条件涵盖不完整的if语句会产生寄存器 有时候会引入不必要的寄存器–&gt; 如果将描述时序的部分放在具有边沿检测条件的if语句或wait语句的进程中，而将描述组合电路的语句放在普通的进程中，这样可以有效控制寄存器的引入。**(双进程，一个负责时序，一个负责组合逻辑电路**) 双进程状态机 12345678910111213141516171819202122232425262728293031323334353637383940414243LIBRARY IEEE ;USE IEEE.STD_LOGIC_1164.ALL ;ENTITY traffic IS PORT( clock , timed , car : IN std_ulogic ; start_timer, major_green, minor_green : OUT std_ulogic );END ENTITY traffic ;ARCHITECTURE asm2 OF traffic IS TYPE state_type IS (G, R); --利用枚举类型定义状态 SIGNAL pr_state, nx_state : state_type; --将状态机的现态、次态定义为全局信号，便于在进程间传递信息BEGIN seq: PROCESS (clock) BEGIN IF(rising_edge(clock)) THEN pr_state &lt;= nx_state;--次态是寄存器的输入 END IF; --条件涵盖不完整的if语句产生状态寄存器 END PROCESS seq; --产生状态寄存器的进程 com: PROCESS (pr_state, car, timed) BEGIN start_timer &lt;= ‘0’; CASE pr_state IS WHEN G =&gt; major_green &lt;= ‘1’; minor_green &lt;= ‘0’; IF (car = ‘1’) THEN start_timer &lt;= ‘1’; nx_state &lt;= R; ELSE nx_state &lt;= G; END IF; WHEN R =&gt; major_green &lt;= ‘0’; minor_green &lt;= ‘1’; IF (timed= ‘1’) THEN nx_state &lt;= G; ELSE nx_state &lt;= R; END IF; END CASE; END PROCESS com; --**产生次态和输出逻辑的进程**END asm2; 双进程中状态变量要定义为SIGNAL类型，用于进程间信息的传递 可以在产生寄存器的进程中加上异步复位语句，用于确定初始状态: &#96;IF reset&#x3D;‘1’ THEN pr_state &lt;&#x3D; G;&#96;&#96; 注意在组合进程中if语句要写完整if-else 三进程状态机 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152LIBRARY IEEE ;USE IEEE.STD_LOGIC_1164.ALL ;ENTITY traffic IS PORT( clock , timed , car : IN std_ulogic ; start_timer, major_green, minor_green : OUT std_ulogic );END ENTITY traffic ;ARCHITECTURE asm2 OF traffic IS TYPE state_type IS (G, R); --利用枚举类型定义状态 SIGNAL pr_state, next_state : state_type; --将状态机的现态、次态定义为全局信号，便于在进程间传递信息BEGIN seq: PROCESS (clock) BEGIN IF(rising_edge(clock)) THEN pr_state &lt;= next_state;--次态是寄存器的输入 END IF; --条件涵盖不完整的if语句产生状态寄存器 END PROCESS seq; --产生状态寄存器的进程 ns: PROCESS (car, timed, pr_state)BEGIN CASE pr_state IS WHEN G =&gt; IF (car = ‘1’) THEN nx_state &lt;= R; ELSE nx_state &lt;= G; WHEN R =&gt; IF (timed = ‘1’) THEN nx_state &lt;= G; ELSE nx_state &lt;= R; END IF; END CASE; END PROCESS ns; --产生次态逻辑进程 op: PROCESS (car, pr_state) -- Mealy State MachineBEGIN start_timer &lt;= ‘0’; IF (pr_state = G) THEN major_green &lt;= ‘1’; minor_green &lt;= ‘0’; IF (car = ‘1’) THEN start_timer &lt;= ‘1’; END IF; ELSE major_green &lt;= ‘0’; minor_green &lt;= ‘1’; END IF; END PROCESS op;--产生输出逻辑的进程END asm3； 表达方式分类 符号化状态机 在程序的说明部分使用TYPE语句定义枚举类型，其元素用状态机的状态名来定义。状态变量（如状态机的现态和次态）定义为变量或信号，并将状态变量的数据类型定义为含有既定状态元素的枚举类型。多进程时：定义为信号，便于信息的传递。（以上三种进程例子皆是符号化状态机） 类型定义语句：TYPE 数据类型名 IS 数据类型定义 OF 基本数据类型;TYPE 数据类型名 IS 数据类型定义; 确定状态编码状态机 二进制编码格雷码编码one-hot 编码 每一个状态都使用二进制位来编码例：实现4状态的状态机，其其二进制编码可为 状态1&#x3D;“00”状态2&#x3D;“01”状态3&#x3D;“10”状态4&#x3D;“11”需要的寄存器数量最少，有n个寄存器就可以对$2^n$个状态进行编码 格雷码：每次仅有一位发生变化特点：触发器使用较少，速度较慢，不会产生两位同时翻转的情况。当状态位的输出被异步应用时，格雷码编码是有益的。 One-hot 编码：每个状态采用一个触发器进行记录以四个状态为例状态1 “0001” 状态2：”0010“ ….. “0100”. “1000”;特点： 触发器使用较多，逻辑简单、速度快 指明表达方式： 12345678910111213ARCHITECTURE BEHAV OF BINARY ISTYPE STATE_TYPE IS(S1, S2, S3, S4, S5, S6, S7);ATTRIBUTE ENUM_ENCODING: STRING;ATTRIBUTE ENUM_ENCODING OF STATE_TYPE: TYPE IS &quot;001 010 011 100 101 110 111&quot;;-- 换成 one-hot 编码ATTRIBUTE ENUM_ENCODING OF STATE_TYPE: TYPE IS &quot;00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000&quot;; 状态机VHDL举例实现Mealy型状态机 对应的代码： 输出端无同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546LIBRARY ieee;USE ieee.std_logic_1164.all;-----------------------------------------------ENTITY simple_fsm IS PORT (a, b, d, clk, rst: IN BIT; x: OUT BIT);END simple_fsm;-----------------------------------------------ARCHITECTURE simple_fsm OF simple_fsm IS TYPE state IS (stateA, stateB); SIGNAL pr_state, nx_state: state;BEGIN----------Lower section: ---------------------- PROCESS (rst, clk) BEGIN IF (rst = &#x27;1&#x27;) THEN pr_state &lt;= stateA; ELSIF (clk&#x27;EVENT AND clk = &#x27;1&#x27;) THEN pr_state &lt;= nx_state; END IF; END PROCESS;-------------Upper section: -------------------- PROCESS (a, b, d, pr_state) BEGIN CASE pr_state IS WHEN stateA =&gt; x &lt;= a; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= stateB; ELSE nx_state &lt;= stateA; END IF; WHEN stateB =&gt; x &lt;= b; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= stateA; ELSE nx_state &lt;= stateB; END IF; END CASE; END PROCESS;END simple_fsm; RTL图： 输出端有同步 123456789101112131415161718192021222324252627282930313233343536373839404142434445LIBRARY ieee;USE ieee.std_logic_1164.all;-----------------------------------------------ENTITY simple_fsm IS PORT (a, b, d, clk, rst: IN BIT; x: OUT BIT);END simple_fsm;-----------------------------------------------ARCHITECTURE simple_fsm OF simple_fsm IS TYPE state IS (stateA, stateB); SIGNAL pr_state, nx_state: state; SIGNAL temp: BIT := &#x27;0&#x27;; -- 多了这个全局的temp,作为中间变量，在改变状态时进行改变BEGIN----------Lower section: ---------------------- PROCESS (rst, clk) BEGIN IF (rst = &#x27;1&#x27;) THEN pr_state &lt;= stateA; ELSIF (clk&#x27;EVENT AND clk = &#x27;1&#x27;) THEN x &lt;= temp; pr_state &lt;= nx_state; END IF; END PROCESS;-------------Upper section: -------------------- PROCESS (a, b, d, pr_state) BEGIN CASE pr_state IS WHEN stateA =&gt; temp &lt;= a; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= stateB; ELSE nx_state &lt;= stateA; END IF; WHEN stateB =&gt; temp &lt;= b; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= stateA; ELSE nx_state &lt;= stateB; END IF; END CASE; END PROCESS;END simple_fsm; RTL图： 仿真对比：结论： 同步之后（利用temp一起作为输出）同时存储了outputMealy型需要该操作才能设计同步时序电路Moore则不需要 使用三种进程描述状态机单，双，三： 单进程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556LIBRARY IEEE;USE IEEE.STD_LOGIC_1164.ALL;ENTITY s_machine1 IS PORT ( clk, reset : IN STD_LOGIC; state_inputs : IN STD_LOGIC_VECTOR (0 TO 1); comb_outputs : OUT INTEGER RANGE 0 TO 15 );END s_machine2;ARCHITECTURE behv OF s_machine1 IS TYPE FSM_ST IS (s0, s1, s2, s3); SIGnAL state: FSM_ST;BEGIN PROCESS (reset, clk, state, state_inputs) BEGIN IF reset = &#x27;1&#x27; THEN state &lt;= s0; ELSIF clk = &#x27;1&#x27; AND clk&#x27;EVENT THEN CASE state IS WHEN s0 =&gt; comb_outputs &lt;= 5; IF state_inputs = &quot;00&quot; THEN state &lt;= s0; ELSE state &lt;= s1; END IF; WHEN s1 =&gt; comb_outputs &lt;= 8; IF state_inputs = &quot;00&quot; THEN state &lt;= s1; ELSE state &lt;= s2; END IF; WHEN s2 =&gt; comb_outputs &lt;= 12; IF state_inputs = &quot;11&quot; THEN state &lt;= s3; ELSE state &lt;= s0; END IF; WHEN s3 =&gt; comb_outputs &lt;= 14; IF state_inputs = &quot;11&quot; THEN state &lt;= s3; ELSE state &lt;= s0; END IF; END CASE; END IF; END PROCESS;END behv; --（完） (请耐心看完) 双进程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859LIBRARY IEEE;USE IEEE.STD_LOGIC_1164.ALL;ENTITY s_machine IS PORT ( clk, reset : IN STD_LOGIC; state_inputs : IN STD_LOGIC_VECTOR (0 TO 1); comb_outputs : OUT INTEGER RANGE 0 TO 15 );END s_machine;ARCHITECTURE behv OF s_machine IS TYPE FSM_ST IS (s0, s1, s2, s3); SIGNAL current_state, next_state : FSM_ST;--------------------------------BEGIN REG: PROCESS (reset, clk) BEGIN IF reset = &#x27;1&#x27; THEN current_state &lt;= s0; ELSIF clk = &#x27;1&#x27; AND clk&#x27;EVENT THEN current_state &lt;= next_state; END IF; END PROCESS; ------------------------------ COM: PROCESS (current_state, state_inputs) BEGIN CASE current_state IS WHEN s0 =&gt; comb_outputs &lt;= 5; IF state_inputs = &quot;00&quot; THEN next_state &lt;= s0; ELSE next_state &lt;= s1; END IF; WHEN s1 =&gt; comb_outputs &lt;= 8; IF state_inputs = &quot;00&quot; THEN next_state &lt;= s1; ELSE next_state &lt;= s2; END IF; WHEN s2 =&gt; comb_outputs &lt;= 12; IF state_inputs = &quot;11&quot; THEN next_state &lt;= s3; ELSE next_state &lt;= s0; END IF; WHEN s3 =&gt; comb_outputs &lt;= 14; IF state_inputs = &quot;11&quot; THEN next_state &lt;= s3; ELSE next_state &lt;= s0; END IF; END CASE; END PROCESS;END behv; 三进程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172LIBRARY IEEE;USE IEEE.STD_LOGIC_1164.ALL;ENTITY s_machine2 IS PORT ( clk, reset : IN STD_LOGIC; state_inputs : IN STD_LOGIC_VECTOR (0 TO 1); comb_outputs : OUT INTEGER RANGE 0 TO 15 );END s_machine2;ARCHITECTURE behv OF s_machine2 IS TYPE FSM_ST IS (s0, s1, s2, s3); SIGNAL current_state, next_state: FSM_ST;BEGIN REG: PROCESS (reset, clk) BEGIN IF reset = &#x27;1&#x27; THEN current_state &lt;= s0; ELSIF clk = &#x27;1&#x27; AND clk&#x27;EVENT THEN current_state &lt;= next_state; END IF; END PROCESS;--状态逻辑------------------------------------------------------ COM_STATE: PROCESS(current_state, state_inputs) BEGIN CASE current_state IS WHEN s0 =&gt; IF state_inputs = &quot;00&quot; THEN next_state &lt;= s0; ELSE next_state &lt;= s1; END IF; WHEN s1 =&gt; IF state_inputs = &quot;01&quot; THEN next_state &lt;= s1; ELSE next_state &lt;= s2; END IF; WHEN s2 =&gt; IF state_inputs = &quot;10&quot; THEN next_state &lt;= s3; ELSE next_state &lt;= s0; END IF; WHEN s3 =&gt; IF state_inputs = &quot;11&quot; THEN next_state &lt;= s3; ELSE next_state &lt;= s0; END IF; END CASE; END PROCESS; --- 次态逻辑--------------------------------------------- COM_OUT: PROCESS (current_state) BEGIN CASE current_state IS WHEN s0 =&gt; comb_outputs &lt;= 5; WHEN s1 =&gt; comb_outputs &lt;= 8; WHEN s2 =&gt; comb_outputs &lt;= 12; WHEN s3 =&gt; comb_outputs &lt;= 14; END CASE; END PROCESS;END behv;-- 输出逻辑 单进程描述的状态机的RTL电路相较于两外两种多了一个 寄存器而 双进程与三进程则对于简单的设计一样（更为建议） 串流数据流检测器设计一个串行数据流检测器。要求：输入连续的二进制数，当检测到连续“1”的个数大于3个的时候，输出“1”；其他状态输出“0”。 分析：确定所需的状态数，取决于数据流中出现连续“1”的个数，应该为4个状态。 画出ASM图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859LIBRARY ieee;USE ieee.std_logic_1164.all;----------------------------------------ENTITY string_detector IS PORT (d, clk, rst: IN BIT; q: OUT BIT);END string_detector;---------------------------------------ARCHITECTURE my_arch OF string_detector IS TYPE state IS (zero, one ,two, three); SIGNAL pr_state, nx_state: state;BEGIN -----------Lower section;----------- PROCESS (rst, clk) BEGIN IF (rst = &#x27;1&#x27;) THEN pr_state &lt;= zero; ELSIF (clk&#x27;EVENT AND clk = &#x27;1&#x27;) THEN pr_state &lt;= nx_state; END IF; END PROCESS; -----------Upper section:------------ PROCESS (d, pr_state) BEGIN CASE pr_state IS WHEN zero =&gt; q &lt;= &#x27;0&#x27;; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= one; ELSE nx_state &lt;= zero; END IF; WHEN one =&gt; q &lt;= &#x27;0&#x27;; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= two; ELSE nx_state &lt;= zero; END IF; WHEN two =&gt; q &lt;= &#x27;0&#x27;; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= three; ELSE nx_state &lt;= zero; END IF; WHEN three =&gt; q &lt;= &#x27;1&#x27;; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= three; ELSE nx_state &lt;= zero; END IF; END CASE; END PROCESS;END my_arch; 综合后是 使用的one-hot 编码如果需要指定编码则可以使用attribute语句将结构体的声明部分添加如下代码 123ATTRIBUTE enum_encoding: string;ATTRIBUTE enum_encoding OF state : TYPE IS &quot;00 01 10 11&quot;; 软件设置： FSM Explorer 选项勾选，综合后也是one-hot编码","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第四章时序逻辑电路","slug":"VHDL第四章时序逻辑电路","date":"2023-02-15T08:35:50.000Z","updated":"2023-02-15T08:36:18.760Z","comments":true,"path":"2023/02/15/VHDL第四章时序逻辑电路/","link":"","permalink":"http://example.com/2023/02/15/VHDL%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","excerpt":"","text":"输出不仅与当前输入有关，还与原始状态有关 组合逻辑电路+ 存储电路（包含有 触发器，寄存器等） 锁存器 触发器 寄存器 计数器 乘法器时序电路引进了 现态和次态的概念可以使用逻辑表达式来进行描述 #分类 按照触发器（动作特点） 同步时序逻辑电路，同一个时钟信号。 异步时序逻辑电路，没有统一的时钟脉冲信号，触发器的变化有前有后。 按照输出信号的特点 米丽（Mealy）输入状态不仅与存储电路状态Q有关，并且与外部输入X有关。 摩尔（Moore）输出状态仅与存储电路的状态Q有关 无关输入X。 时序逻辑电路——锁存器 RS锁存器根据真值表来进行判断 S R Q ~Q 0 0 1 1 0 1 0 1 1 0 1 0 1 1 Q ~Q 123456789101112131415161718192021Library ieee;Use ieee.std_logic_1164.all;Entity SR_latch2 is port ( S, R: in std_logic ; Q, Qbar :out std_logic);End SR_latch2;Architecture behav of R_latch2 isBegin process ( R , S ) is variable rs: std_logic_vector(1 downto 0);begin rs:=R&amp;S; case rs is when &quot;00&quot; =&gt; Q&lt;=&#x27;1&#x27;; Qbar&lt;=&#x27;1&#x27;; when &quot;01&quot; =&gt; Q&lt;=&#x27;1&#x27;; Qbar&lt;=&#x27;0&#x27;; when &quot;10&quot; =&gt; Q&lt;=&#x27;0&#x27;; Qbar&lt;=&#x27;1&#x27;; when others=&gt;null; end case; end process;end behav;--敏感参数有R和S D锁存器D锁存器通过条件涵盖不完整的if语句 产生寄存器；#值得一看敏感参数表包含D、Enable，综合后 形成一个电平触发的锁存器 123456789101112131415Library ieee;Use ieee.std_logic_1164.all;Entity D_latch is port ( D, Enable: in std_logic ; Q: out std_logic );End D_latch;Architecture behav of D_latch isBegin process(D, Enable) begin if (Enable=‘1’) then Q&lt;=D; end if; end process;End behav; 触发器触发器是指边沿触发的寄存器，常见的有D型，JK型，T型。在描述触发器前要注意时钟上升沿的描述 D触发器一个D 一个Clock输出一个Q 12345678910111213141516171819202122232425library ieee;use ieee.std_logic_1164.all;entity d_ff1 is port(D,clk: in std_logic; Q:out std_logic);end d_ff1;architecture behav of d_ff1 isbegin process(clk) begin if(clk&#x27; event and clk = &#x27;1&#x27;) then Q&lt;=D; end if ; end process;end behav;---第二种方式 process begin wait until (clk=‘1’) ; --等同于 wait until clk’event and clk=‘1’； Q&lt;=D; end process;End behav; 时钟边沿检测到的方法 #值得一看 上升沿：clock’ event and clock&#x3D;‘1’下降沿：clock’ event and clock&#x3D;‘0’; 利用WAIT语句启动进程，检测colck的上升沿 Process 和 if语句的相结合 利用clk启动进程，并进行判断 带Q非的D触发器不是简单的按照前面直接加上一个Qbar如Qbar = NOT D时钟上升沿会有两个赋值，导致有两个D触发器 解决方式 信号法： 12345678910111213141516architecture sig of D_ff is signal state: std_logic;begin process(clock, reset) begin if(reset=&#x27;0&#x27;)then state&lt;=&#x27;0&#x27; else if rising_edge(clock) then state&lt;=D; end if; end process; Q&lt;=state; Qbar&lt;=not state;end sig;--利用信号作为中间变量，D触发器 变量法： 123456789101112131415Architecture var of D_FF is Begin process(clock, reset) variable state: std_logic ; begin if (reset=‘0’) then state:=‘0’; elsif rising_edge(clock) then state:=D; end if; Q&lt;=state; Qbar&lt;=not state; end process;End var;--跟变量法相似，只是state的范围限定在process内 JK触发器四个输入J K R（reset） Clock 两个输出 Q Qbar J K Q Qbar 0 0 Q Qbar 0 1 0 1 1 0 1 0 1 1 Qbar Q 12345678910111213141516171819202122232425entity JK_ff is port(J,K: in std_logic; clock,reset: in std_logic; Q, Qbar: out std_logic);end JK_ff;architecture behav of JK_ff issignal state:std_logic;begin process( clock, reset) is variable jk: std_logic_vector(1 downto 0); begin jk:=J&amp;K; if (reset=‘0’) then state&lt;=‘0’; elsif rising_edge(clock) then case jk is when “11”=&gt; state&lt;=not state; when “10”=&gt; state&lt;=‘1’; when “01”=&gt; state&lt;=‘0’; when others =&gt; null; end case; end if;end process; Q&lt;=state; Qbar&lt;=not state ;end behav **CASE语句要完整,所以在CASE JK的时候要加when others &#x3D;&gt;null; T触发器 1234567891011121314151617181920Entity T_FF is port ( T, clock, reset : in std_logic ; Q, Qbar : out std_logic );End T_FF;Architecture behav of T_FF isBegin process(clock, reset) variable state: std_logic ; begin if (reset =‘0’) then state:=‘0’; elsif rising_edge(clock) then if T=‘1’then state := not state; end if; end if ; Q&lt;=state; Qbar&lt;= not state; end process;End behav ; 寄存器的设计一个D触发器就是一个寄存器，多位可以由多个D触发器构成 1234567891011121314151617Entity reg is generic( n: natural :=4 ); --实体类属中的常数 port ( D: in std_logic_vector(n-1 downto 0); clock, reset : in std_logic; Q: out std_logic_vector (n-1 downto 0) );End reg ;Architecture behav of reg isBegin process(clock, reset) begin if (reset=‘0’) then Q&lt;=( others=&gt;‘0’); --表示Q赋全‘0’ elsif rising_edge(clock) then Q&lt;=D; end if; end process;End behav ; 移位寄存器 1234567891011121314151617181920Entity sipo is generic( n : natural :=8); port ( a : in std_logic ; q: out std_logic_vector(n-1 downto 0); clk : in std_logic );End sipo;Architecture behav of sipo isBegin process(clk) variable reg : std_logic_vector(n-1 downto 0); begin if rising_edge(clk) then reg : = reg ( n-2 downto 0) &amp; a ; --左移移位寄存器； -- reg : = a &amp; reg (n-1 downto 1); 右移移位寄存器 end if ; q&lt;= reg ; end process;End behav; 计数器用“+”函数描述 12345678910111213141516171819202122232425Library ieee ;Use ieee.std_logic_1164.all;Use ieee.std_logic_unsigned.all;Entity counter is generic( n: natural :=4); port ( clk : in std_logic; reset : in std_logic ; count : out std_logic_vector(n-1 downto 0) );End counter;architecture ripple of counter is component T_FF is port( T: in std_logic ; clk:in std_logic; reset:in std_logic; Q : out std_logic; Qbar:out std_logic); end component ; --将前面描述好的T触发器定义为元件； signal carry: std_logic_vector( n downto 0);Begin carry(0)&lt;=clk; g0: for i in 0 to n-1 generate --循环 T1: T_FF port map ( ‘1’, carry( i ), reset, count( i ), carry( i+1 ) ); end generate g0;End ripple ; 波形仿真： 总结","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第三章组合逻辑电路","slug":"VHDL第三章组合逻辑电路","date":"2023-02-15T08:34:19.000Z","updated":"2023-02-15T08:35:26.934Z","comments":true,"path":"2023/02/15/VHDL第三章组合逻辑电路/","link":"","permalink":"http://example.com/2023/02/15/VHDL%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","excerpt":"","text":"数字电路按照完成逻辑功能的不同特点， 组合逻辑电路 任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关 电路没有记忆功能 电路结构上不存在反馈路径 常见的有简单门电路，选择器，译码器，三态门 时序逻辑电路 任意时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态，或者说，还与以前的输入有关。 设计方法使用可编程逻辑器件，用硬件语言描述的EDA设计方法（1）逻辑问题的描述。将设计问题转化为一个逻辑问题（2）根据逻辑问题，用硬件描述语言进行描述（3）对描述进行综合，仿真测试（4）生成最终网表，下载到芯片 描述方法 数据流描述： 并行语句 结构 ：组件和互连 行为(时序)：顺序语句 寄存器 状态机 指令解码 VHDL 数据流设计风格可以变成 VHDL 代码，反之不可行 并行信号赋值（&lt;&#x3D;) 条件并行信号赋值（when -else) 选择并行信号赋值（with-select-when） for generate 注意优先级 y &lt;= (a and b) or (c and d) ;同一个信号不能出现在并行赋值语句的两边 也就是&lt;&#x3D; 门电路四种基本操作：与，或，非，，触发器操作，以与非门为例 1234567891011library ieee;use ieee.std_logic_1164.all;entity nand2 is port (a,b: in std_logic; y: out std_logic);end nand2;architecture behav of nand2 isbegin y &lt;= a nand b;end behav;-- 如果吧nand变为nor就是或非 译码器输入为二进制代码，输出是一组高低电平信号变量码制变换显示译码~ 地址译码~ 以3-8译码器为例3个输入端 abc,。 g1,g2a,g2b为选择信号当g1 &#x3D;’1’, ‘0’’0’为例，正常工作 1234567891011121314151617181920212223library ieee;use ieee.std_logic_1164.all;entity decoder is port (a,b,c,g1,g2a,g2b: in std_logic; y: out std_logic_vector(7 downto 0);end decoder;architecture behav of decoder issignal indata: std_logic_vector(2 downto 0);begin indata &lt;= c&amp;b&amp;a; process(indata,g1,g2a,g2b) begin if (g1=&#x27;1&#x27; and g2a = &#x27;0&#x27;and g2b = &#x27;0&#x27;) then case indata is when &quot;000&quot; =&gt; y &lt;=&quot;11111110&quot;; when /.... .... end case; else y&lt;= &quot;11111111&quot;; end if; end process;end behav; 编码器它的输入是一组高低电平信号，输出是一组二进制代码优先级编码器74ls1483位二进制码输出的优先级编码当有多个输入时，有优先级 12345678910111213141516171819202122Library IEEE;Use IEEE.std_logic_1164.all;Entity priorityencoder is Port ( input : in std_logic_vector (7 downto 0 ); y: out std_logic_vector( 2 downto 0) );End priorityencoder;Architecture behav of priorityencoder isBegin Process(input) Begin If ( input(0)=‘0’) then y&lt;=“111”; elsif ( input(1)=‘0’) then y&lt;=“110”; elsif ( input(2)=‘0’) then y&lt;=“101”; elsif ( input(3)=‘0’) then y&lt;=“100”; elsif ( input(4)=‘0’) then y&lt;=“011”; elsif ( input(5)=‘0’) then y&lt;=“010”; elsif ( input(6)=‘0’) then y&lt;=“001”; elsif ( input(7)=‘0’) then y&lt;=“000”; else y&lt;=“XXX”; end if; End process;End behav; #值得一看 加法器半加 全加（有进位）前者两个输入，两个输出后者三个输入，两个输出 12345678910111213LIBRARY ieee;USE ieee.std_logic_1164.all;ENTITY full_add ISPORT ( X,Y,Z:in bit; Sum,Carry:out bit);END full_add;ARCHITECTURE a OF full_add ISBEGIN Sum &lt;= X xor Y xor Z; Carry&lt;=(X and Y) or (Y and Z) or (Z and X);END a; -- 对于这些操作可以看真值表 #模块化处理 12345678library ieee;use ieee.std_logic_1164.allpackage components is COMPONENTS fadd is port(a,b,ci: in std_logic; co,sum:out std_logic); end fadd;end components; 三态门12345678910111213141516Library IEEE;Use IEEE.std_logic_1164.all;Entity tri_gate is port ( din , en : in std_logic; dout : out std_logic );End tri_gate ;Architecture behav of tri_gate isBegin process ( din ,en) begin if (en=‘1’) then dout&lt;=din; else dout&lt;=‘Z’; end if ; end process; End behav; 缓冲器缓冲寄存器，在总线传输中起数据暂存缓冲输入缓冲，输出缓冲单向与双向之分 1234567891011121314151617181920212223242526272829Library IEEE;Use IEEE.std_logic_1164.all;Entity tri_bigate is port ( a , b: inout std_logic_vector(7 downto 0) ; en , dr : in std_logic );End tri_bigate ;Architecture behav of tri_bigate is signal aout , bout :std_logic_vector ( 7 downto 0 );Begin process ( a , dr , en) begin if ( (en=‘0’) and ( dr=‘1’) ) then bout&lt;=a; else bout&lt;=“ZZZZZZZZ”; end if ; b&lt;=bout ; end process; process ( b , dr , en) begin if ( (en=‘0’) and ( dr=‘0’) ) then aout&lt;=b; else aout&lt;=“ZZZZZZZZ”; end if ; a&lt;=aout ; end process; End behav;","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第二章语法基础","slug":"VHDL第二章语法基础","date":"2023-02-15T08:33:03.000Z","updated":"2023-02-15T08:33:51.125Z","comments":true,"path":"2023/02/15/VHDL第二章语法基础/","link":"","permalink":"http://example.com/2023/02/15/VHDL%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Very-High-Speed Integrated circuit Hardware Description Language 用途 主要用于描述字系统的结构、行为、功能和接口VHDL侧重于系统描述，更适合系统级设计 具有 硬件特征，并且是并行执行方式 基本结构 库的调用 ——相当于操作系统中的目录 程序包的调用 —— 类似于include 实体说明—— 用于说明设计系统的外部接口信息 结构体 —— 描述行为 VHDL的主要构件 基本构件：库、包、配置、实体、结构体、块、子程序（函数以及过程） 主要构件：库 程序包 实体 结构体1print (hello) 库： LIBRARY + 库名 库(Library)是编译后数据的集合，是存放预先完成的程序包和数据集合体的仓库。 std库 IEEE库，work库（默认库）。面向asic的库，哈hi有自定义的库 123LIBRARY IEEE;USE IEEE.std_logic_1164.ALL;;USE IEEE.std_logic_unsigned.ALL; 一般使用的是IEEE库，有四个常用的程序包 std_logic_1164 std_logic_arith std_logic_signed std_logic_unsigned 包1USE IEEE.STD_LOGIC_1164.ALL 不同的包，一样的语句会产生不同的形式的结果 实体包括实体名，类属参数说明，端口说明由”ENTITY” 引导 1234ENTITY 实体名 IS [类属参数说明]； [端口说明]；END [ENTITY] [实体名]； 以END ENTITY 结尾 类属参数说明 说明静态信息&#96;GENERIC (常数名：数据类型: &#x3D;设定值)1GENERIC(m:time:= 1ns); 端口说明提供外部接口信息PORT (端口名：端口方向 数据类型）1PORT(d0:IN std_logic) 例子 结构体ARCHITECTURE 设计实体的具体描述，指明具体行为，两部分 定义说明和具体功能描述 12345678910ARCHITECTURE 结构体 OF 实体名 IS[定义语句] 信号 (signal); 常数 (constant); 数据类型(type); 函数(function); 原件(component);BEGIN [并行处理语句]；END 结构体名； 语句并行结构体的描述方法： 行为描述、数据流描述、结构描述 配置描述层与层之间的连接关系和实体和结构体之间的连接关系 123CONFIGURATION 配置名 OF 实体名 IS [语句说明];END 配置名; 作用：利用配置语句来选择不同的结构体 数据类型以及运算符10种标准数据类型还有用途 还由用户自定义的数据类型 123TYPE 数据类型名 IS 数据类型定义 OF 基本数据类型或 TYPE 数据类型名 IS 数据类型定义 常用的有 枚举类型， 子类型 整数类型和实数类型 1TYPE week IS (sum, mon, tue, wed, thu, tri, sat); --枚举类型 12SUBTYPE natural IS integer range 0 to integer’high--子类型 1234567891011TYPE percent IS INTEGER RANGE -100 TO 100-- 整数类型和实数类型TYPE 数组名 IS ARRAY(数组范围) OF 数组类型；数组类型TYPE 记录类型名 IS RECORD 元素名：元素数据类型； 元素名: 元素数据类型：END RECORD;-- 记录类型 数据类型转换std_logic_1164: TO_STDLOGICVECTOR(A) –&gt; 由 BIT_VECTOR 转换为STD_LOGIC_VECTOR TO_BITVECTOR(A) –&gt;BIT转到bitvector() TO_STDLOGIC(A) –&gt;由BIT转 换STD_LOGIC TOBIT(A) std_logic_arich: CONV_STD_LOGIC_VECTOR(A,n)(n为位长) integer unsigned signed 转换为std_logic_vector CONV_INTEGER(A) unsigned signed 转换为integer std_logic_unsigned: conv_integer(A) ,std_logic_vector转换为integer 运算符 数据对象可以赋值的都叫做 对象 常量：设计中不变的值 变量 ： 定义在进程中或子程序种的变化量 对应硬件内部实实在在的连线 12345CONSTANT 常数名：数据类型：=表达式 CONSTANT fbus:bit_vector:=“0101”--总线上的数据向量 全局的量 1234VARIABLE 变量名：数据类型:= 初始值VARIABLE time:integer RANGE 0 TO 6 --进程中代表次数的变化 局部量对变量的赋值是立即生效的 1SIGNAL 信号名:数据类型:=表达式 “:&#x3D;”表示对信号的赋初值，一般不产生延时。“&lt;&#x3D;”表示信号的代入赋值，有延时。 信号赋值有延迟；而变量赋值没有延迟。 进程对信号敏感，对变量不敏感。信号可以是多个进程的全局信号, 而变量只在定义它的进程中可见 在描述中，信号的赋值不会立即生效，而是要等待一个delta延迟后才会变化，否则该信号的值在delta延迟之前仍是原来的值。 变量存储临时数据 保存中间结果(：&#x3D; ）赋值立即发生，进程内有效常量用于保存静态数据信号有延时（&lt;&#x3D;) 跨进程 基本语句具有顺序和并行语句（特点顺序语句需要用process进行封装“–”表示注释 并行语句包括7种语句 赋值语句 条件赋值语句、 选择信号赋值语句、 进程语句 元件例化语句 生成语句 子程序调用语句 赋值语句 信号 &lt;&#x3D;变量和常量 :&#x3D; 条件赋值语句a &lt;&#x3D; 表达式1 when 条件 else 表达式2 when 条件 else … 表达式n； 只有最后一句需要分号 选择信号赋值逗号和分号的作用情况with instrution selecta &lt;&#x3D; b when “100”,…‘Z’ when others; 进程语句process本身就是一个并行语句，内部是顺序语句 启动方式有两种：敏感参数以及wait语句 敏感参数： process(参数) 只要参数一变化，process就会启动 wait语句：processbegin output &lt;&#x3D; in1 OR in2; wait on in1,in2;END PROCESS; 等待in1, in2信号发生变化，进程再次执行 进程的启动只能是信号敏感参数以及wait 语句不能混用当一个进程执行结束后，先挂起来，直到有新的启动信号变化为止 元件例化语句 生成语句有IF 和FOR来控制的 子程序调用语句子程序调用 ：过程调用语句和函数调用 顺序语句 IF语句 可以和 when else 互换 123IF reset=‘0’ THEN q&lt;=‘0’;ELSIF ‘clk’ event AND clk=‘1’ THEN q&lt;=d; END IF; CASE语句 可以和 with else语句互换 12345678CASE sel IS WHEN 0=&gt; y&lt;=d0； WHEN 1=&gt; y&lt;=d1； WHEN OTHERS&lt;=NULL;END CASE LOOP语句 EXIT 和 NEXT语句（loop内部的循环控制语句） 其他顺序语句 wait语句wait on 信号表wait until 条件表达式wait for 时间表达式 返回语句RETURN仅用于子程序 空操作语句NULL常用于CASE语句中 属性描述语句具有属性的项目有很多： 类型，子类型，过程，函数，信号，变量，常量，实体，结构体，配置，程序包，元件和语句标号等，属性是这些项目的特性 预定义描述语句格式：属性对象’属性名 1.信号类属性EVENT表示信号发生率动作，stable表示无事件发生 123456NOT clock`STABLE AND clock = &#x27;1&#x27;; --检测时钟上升沿clock`EVENT AND clock=&#x27;1&#x27;; --检测时钟上升沿还有 s`delayed(time)s&#x27;stables&#x27;quiet(time) 2. 数值区间类属性RANGE和REVERSE_RANGE 3. 数值类属性.LEFT &#39;RIGHT HIGH LOW之类 4. 数组属性’LENGTH 对宽度进行获取 5. 用户自定义的属性ATTRIBUTE 属性名 OF 对象名：对象类型 IS 值 其他构建 块是一种划分 ，不影响综合，将模块划分为数个区域 函数 &#96;&#96;&#96; FUNCTION 函数名（参数表）RETURN 数据类型； FUNCTION 函数名（参数表）RETURN 数据类型 IS [说明部分]； [说明部分]； BEGIN 顺序语句； END 函数名； &#96;&#96;&#96; 过程 PROCEDURE 和函数一样 两部分组成 过程首和过程体 函数和过程都是顺序语句，并且不能说明信号过程参数表一般要定义参量的流向模式，如果没有指定默认为IN过程中可以有WAIT语句（但综合器一般不支持），函数中能过程有多个返回值，函数只有一个 还有程序包示例： 还有TEXTIO构件","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"通原笔记_1（1至2章）","slug":"通原笔记-1","date":"2023-01-24T15:42:26.000Z","updated":"2023-01-24T15:59:52.914Z","comments":true,"path":"2023/01/24/通原笔记-1/","link":"","permalink":"http://example.com/2023/01/24/%E9%80%9A%E5%8E%9F%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"​ 最近愈发觉得在蹉跎时间，也稍微把游戏放一放，现在更能感受到人的“温度”，而不是打完游戏之后的一身虚无以及疲惫、无知。 选择西安电子科技大学通信原理观看，也把之前很多不懂的地方重新认识了一遍，借此文来记录笔记。 第一章","categories":[],"tags":[{"name":"通信原理 笔记","slug":"通信原理-笔记","permalink":"http://example.com/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86-%E7%AC%94%E8%AE%B0/"}]},{"title":"初晴","slug":"初晴","date":"2023-01-14T15:45:42.000Z","updated":"2023-01-15T08:56:01.213Z","comments":true,"path":"2023/01/14/初晴/","link":"","permalink":"http://example.com/2023/01/14/%E5%88%9D%E6%99%B4/","excerpt":"","text":"​ 下了两天的小雨，地上，墙上都是湿漉漉的，没想到下午的开始放晴了。雨后初晴，天实在是很干净。就好像在一块蓝色的幕布上撒下了这些云彩一般，望向天空，注意力很难不被这些”小可爱”所吸引，看着它，仿佛有摄人心魄的能力，仿佛心也随之飘荡在蓝天之上没一下子就开阔起来。 这是附近的基站，从小时候便有了，距今好像也有近乎十年的历史了，仍然矗立在那，配上背后的云彩，便有了一种独特，我难以描述的美感。 这两张照片是在田地里拍摄的，当时的天空还有太阳在照着，但慢慢的，便被这片云藏了起来。站在广阔的田里，抬头便是这篇云，细看其中，有种漫威电影里的混沌的感觉，觉得颇为有趣","categories":[],"tags":[{"name":"风景 感悟","slug":"风景-感悟","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF-%E6%84%9F%E6%82%9F/"}]},{"title":"勇气","slug":"勇气","date":"2023-01-12T14:30:37.000Z","updated":"2023-01-13T16:08:38.320Z","comments":true,"path":"2023/01/12/勇气/","link":"","permalink":"http://example.com/2023/01/12/%E5%8B%87%E6%B0%94/","excerpt":"","text":"​ 《被讨厌的勇气》 《月光落在左手上》 ​ 今天又重拾起一本曾经读过的书，虽然读过，但只是浅浅的读了一遍，受益匪浅，但是对于现在的我来说仍然有很多未解之谜。最近这两年来，也发现自己有暴躁的倾向，内心也时常久久不能平静，便萌生了再读一遍的想法。至于第二本书，余秀华女士的诗歌，或许也能打开我的一扇新世界的大门。 ​ 被讨厌的勇气 开篇的两句话便可见这本书对于很多人都有很大的作用 ​ 月光落在左手上 诗的名字：我爱你，巴巴的活着，这何尝不是大部分人的写照呢，机械般的活着。把自己比喻作陈皮，在阳光下才能舒展开来，不同的茶叶便能带来心中的美好，平平淡淡的生活中，都有让自己开心的事物存在，但是诗人自身的不幸，痛苦在这个时候又将其拉回现实，这便是内心的雪。诗人表示自己并不会这么容易肝肠寸断，因为诗人把自己比作那稗子一样，长在稻谷周围，很相似，但是却并不是那稻子，只是一种极其不受欢迎的野草。诗人在庭院之中读着心爱之人的诗歌，以突然飞过的麻雀儿寓意时光的飞逝。稻子和稗子都渴望春天，但是稗子的渴望中又带着“提心吊胆”。一不小心便会失去。 就连耶稣用稗子设过比喻：“天国，好像人撒好种子在田里。有仇敌来，将稗子撒在麦子里，就走了。好种就是天国之子。稗子就是那恶者之子。撒稗子的仇敌就是魔鬼。收割的时候就是世界的末了。”Link 所以便有了：活为稗子，提心吊胆。","categories":[],"tags":[{"name":"被讨厌的勇气 读书 月光落在左手上","slug":"被讨厌的勇气-读书-月光落在左手上","permalink":"http://example.com/tags/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94-%E8%AF%BB%E4%B9%A6-%E6%9C%88%E5%85%89%E8%90%BD%E5%9C%A8%E5%B7%A6%E6%89%8B%E4%B8%8A/"}]}],"categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"},{"name":"通信原理 笔记","slug":"通信原理-笔记","permalink":"http://example.com/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86-%E7%AC%94%E8%AE%B0/"},{"name":"风景 感悟","slug":"风景-感悟","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF-%E6%84%9F%E6%82%9F/"},{"name":"被讨厌的勇气 读书 月光落在左手上","slug":"被讨厌的勇气-读书-月光落在左手上","permalink":"http://example.com/tags/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94-%E8%AF%BB%E4%B9%A6-%E6%9C%88%E5%85%89%E8%90%BD%E5%9C%A8%E5%B7%A6%E6%89%8B%E4%B8%8A/"}]}