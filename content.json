{"meta":{"title":"My Lady Shen","subtitle":"","description":"","author":"YY Huang","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"VHDL第六章仿真","slug":"VHDL第六章仿真","date":"2023-02-16T12:53:34.000Z","updated":"2023-02-16T12:54:04.749Z","comments":true,"path":"2023/02/16/VHDL第六章仿真/","link":"","permalink":"http://example.com/2023/02/16/VHDL%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BB%BF%E7%9C%9F/","excerpt":"","text":"啥是仿真： 对设计的硬件描述和设计结果 通过计算级查错、验证的过程仿真（模拟） 从电路的描述（语言描述或图形描述）抽象出模型，然后将外部激励信号或数据施加于此模型，通过观察该模型在外部激励下的反应来判断该电路系统是否实现预期的功能。 目的 检查原始描述的正确性； 检查设计结果在逻辑功能和时序上的正确性； 检查设计结果中不含违反设计规则的错误。 级别 高层次仿真： 对系统的抽象行为算法或混合描述的电路进行的仿真。仿真的重点是系统功能和系统内部运算过程。 RTL级仿真 ：对基于RTL方法描述的电路进行的仿真。重点是仿真数据在系统内元件之间的流动关系。 逻辑仿真：对基于门、触发器、和功能块构成的系统进行的仿真。其方法是通过对电路施加激励，观察电路对激励的响应来判断电路的功能是否正确。检查其逻辑功能、延迟特性和负载特性等。 电路级仿真：对基于晶体管、电阻、电容等构成的电路进行的仿真。其方法是通过求解电路方程而得出电路电压和电流，从而求出电路输出波形的一种模拟（如PSPICE）。特点：仿真时间长、精度高。 开关级仿真：介于电路级和逻辑级之间的模拟。将电阻、电容不当作一个元件而当作晶体管和节点的参数来处理的一种模拟方法。其复杂度和仿真时间介乎于电路级与逻辑级之间。 仿真（模拟）的级别 逻辑模拟模型电路模型 电路网表： 逻辑电路是元件的集合。 指描述电路拓扑关系的一种数据结构。如果指定了每个元件各端口所连接的信号，就可以唯一确定电路的连接关系。每个元件有其元件模型。 一个元件E的描述包含有元件名N、模型M、输入端信号PI和输出端信号PO四部分。即 E&#x3D;（N，M，PI，PO） 元件N 模型M 输入信号PI 输出信号PO 以一位加法器的网表为例 负载表在仿真时需要频繁查找每个信号后所连接的元件，称为负载元件还是以上面的图为例 X信号后面接的是 E1、E3Y 信号后面的是： E1、 E3同理可得到所有的负载：CIN： E2，E4； S1： E2，E4； S2： E5； S3： E5； SUM： Ø；COUT： Ø 元件模型门的模型 功能、参数、扇入、扇出、延迟时间功能块的模型 功能和行为描述，不关系其内部结构和组成 信号模型二值模型、三值模型、四值模型、五值、九值 信号值强度表示 信号的驱动能力强制级F：信号连接电源或地，或者是一些输入激励；电阻级R：信号通过一较大的电阻与电源或地相连；高阻级Z：信号与电源和地相隔离 九值模型逻辑电平：0、1、未知X强度：强制F、弱W、高阻Z、未定U和无关-每个值为逻辑电平与强度的组合，其中高阻、未定和无关只有一个电平值（未知） 延迟模型1. 元件延迟 零延迟模型：理想元件； 单位延迟模型：所有元件延迟时间相同，单位为1个时间单位； 标准延迟模型： 对每种元件设定一个标准延迟时间，不考虑元件的离散性； 上升下降延迟模型：分别考虑上升下降延迟时间；模糊延迟模型：给出元件的最大最小延迟时间； 2. 惯性延迟与传输延迟 惯性延迟： 输入脉冲信号能在得到相应所需最小脉冲宽度 传输延迟： 信号通过元件和连线传输过程中所引起的延迟 前者在VHDL语句中，不做说明的一定是惯性延迟。当信号脉冲宽度小于器件的固有延时时，器件将不对输入信号作出任何反应。 Z &lt;= X;(惯性延时缺省) Z &lt;&#x3D; X AFTER 3 ns;（ 3ns的惯性延时）&#96; 后者 (TRANSPORT)传输延时常用于描述总线延时、连线延时及ASIC芯片中的路径延时。输出端信号在经过传输延时后，将完全复现输入端的波形&#96;Z &lt;&#x3D; TRANSPORT X AFTER delay; (只有传输延时) 思考题：Vo &lt;= Vi AFTER 4ns; 1 ) 有脉冲输出2 ）无3 ）有 延迟为4ns4 ) 有传播延迟，所以不考虑惯性延迟有脉冲输出（不管多小） 仿真过程 搭建好电路并进行编译。 将编译好后形成的网表放入数据库中。 产生波形文件。当仿真启动后，将读取数据库文件，生成模拟驱动程序，连同波形文件，输出结果。","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第五章状态机的设计","slug":"VHDL第五章状态机的设计","date":"2023-02-16T07:55:39.000Z","updated":"2023-02-16T07:56:11.512Z","comments":true,"path":"2023/02/16/VHDL第五章状态机的设计/","link":"","permalink":"http://example.com/2023/02/16/VHDL%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"时序电路 &#x3D; 组合逻辑+存储电路 三位计数器从000到111，循环往复以上升沿触发的D触发器作为状态寄存器次态和现态的真值表 又因为计数器需要使用到3个状态寄存器（即是3个状态寄存器）通过卡诺图的推导（次态方程出错）根据次态方程画出详细的电路 时序电路与状态机 状态机的本质 具有逻辑顺序或时序规律事件的一种描述方法。具有逻辑顺序和时序规律的事件都适合用状态机描述同步时序逻辑电路符合状态机的一般特征。 便可以使用状态机来描述 三个基本要素： 状态 ：状态变量 输出：某一个状态时特定发生的事件 输入： 进入状态的条件 电路的竞争与冒险竞争：多径信号汇合在一路，时间上有先有后。（殊途同归）冒险： 因为竞争导致电路输出错误的现象。 组合逻辑电路存在该问题，所以时序逻辑电路也一样面临着这个问题使用同步时序逻辑电路可以克服次态逻辑的上述问题 课本上消除竞争与冒险的方法： 考虑接入滤波电容 （简单但影响输出） 修改逻辑设计（电路往往十分复杂） 引入脉冲（对信号的时钟周期有所限制） 时钟周期的选取在时序电路中，存在 3个重要的时序参数$$建立时间t_{su}、保持时间t_{hold}、传播时延t_{c-q}$$ $t_{su}$ 建立时间： 触发器的时钟信号上升沿到达之前，数据稳定的时间$t_{hold}$ 数据输入触发器所需的时间$t_{c-q}$ 信号传播路径上传播所需要的时间 在同步时序电路中，假设电路其中一级最长的延时为$t_{plogic}$综上所述：$$时钟周期T 应该满足————T&gt; t_{su}+t_{c-q} + t_{plogic}$$#值得一看 有限状态机的描述方法ASM图（Algorithmic State Machine）其中蕴含着时序的关系，类似流程图。 ASM图的组成部分 状态框： 使用矩形框来表示状态 ， 状态名写在左上角，二进制编码写在右上角 ，操作内容写在方框内，该状态经历的时间至少为一个时钟周期。 判断框 棱形框表示 内部是条件，分支需要写明相应条件 条件框： 椭圆框表示 条件框必定与 判断框相连仅当判断框中判断变量满足相应的转移条件时，才进行条件框中标明的操作和信号输出 跟状态框有相似 但也有很大差别 状态单元 单个条件框 或者状态框组成 每一个状态单元表示一个时钟周期下 系统的状态 交通灯ASM图解答： 有限状态机的分类信号输出 ： Mealy （与当前状态有关，还与外部输入有关，首尾相连） Moore（仅与当前状态有关）结构： 单进程 双进程 三进程表达方式：符号化 状态机、确定状态编码状态机（顺序编码、onehot编码 格雷码状态机） 使用的判断条件: Moore型的输出与当前的输入部分无关，所以当前输出产生的人和效果将会延迟到下一个时钟周期 最大优点：将输入部分和输出部分隔离 Mealy 型，输出是输入的函数，所以当输入信号改变时，输出将在一个时钟周期内发生改变 单进程描述：它就是将状态机的三个逻辑单元（状态寄存器、下状态产生逻辑、输出逻辑）合并起来，采用一个进程描述 单进程状态机 还是以交通灯为例 123456789101112131415161718192021222324252627282930313233LIBRARY IEEE ;USE IEEE.STD_LOGIC_1164.ALL ;ENTITY traffic IS PORT( clock , timed , car : IN std_ulogic ; start_timer, major_green, minor_green : OUT std_ulogic );END ENTITY traffic ;ARCHITECTURE asm1 OF traffic IS BEGIN PROCESS （clock, timed, car) TYPE state_type IS (G, R); --这里采用符号化状态机的描述方式 VARIABLE state: state_type; --将状态定义为变量类型 BEGIN IF (rising_edge(clock)) THEN CASE state IS WHEN G =&gt; major_green &lt;= ‘1’; minor_green &lt;= ‘0’; IF (car = ‘1’) THEN start_timer &lt;= ‘ 1’; state := R; END IF; WHEN R =&gt; major_green &lt;= ‘0’; minor_green &lt;= ‘1’; IF (timed= ‘1’) THEN start_timer &lt;= ‘ 1’; state := G; END IF; END CASE; END IF END PROCESS;END ARCHITETURE; 单进程状态变量可以定义为变量类型，放在进程的说明部分 进程开头有时钟有效边沿的检测语句 注意在这里进程敏感参数表中的car和timed可省去rising_edge(clock)也可以写成clock’event and clock&#x3D;‘1’ if条件涵盖不完整的if语句会产生寄存器 有时候会引入不必要的寄存器–&gt; 如果将描述时序的部分放在具有边沿检测条件的if语句或wait语句的进程中，而将描述组合电路的语句放在普通的进程中，这样可以有效控制寄存器的引入。**(双进程，一个负责时序，一个负责组合逻辑电路**) 双进程状态机 12345678910111213141516171819202122232425262728293031323334353637383940414243LIBRARY IEEE ;USE IEEE.STD_LOGIC_1164.ALL ;ENTITY traffic IS PORT( clock , timed , car : IN std_ulogic ; start_timer, major_green, minor_green : OUT std_ulogic );END ENTITY traffic ;ARCHITECTURE asm2 OF traffic IS TYPE state_type IS (G, R); --利用枚举类型定义状态 SIGNAL pr_state, nx_state : state_type; --将状态机的现态、次态定义为全局信号，便于在进程间传递信息BEGIN seq: PROCESS (clock) BEGIN IF(rising_edge(clock)) THEN pr_state &lt;= nx_state;--次态是寄存器的输入 END IF; --条件涵盖不完整的if语句产生状态寄存器 END PROCESS seq; --产生状态寄存器的进程 com: PROCESS (pr_state, car, timed) BEGIN start_timer &lt;= ‘0’; CASE pr_state IS WHEN G =&gt; major_green &lt;= ‘1’; minor_green &lt;= ‘0’; IF (car = ‘1’) THEN start_timer &lt;= ‘1’; nx_state &lt;= R; ELSE nx_state &lt;= G; END IF; WHEN R =&gt; major_green &lt;= ‘0’; minor_green &lt;= ‘1’; IF (timed= ‘1’) THEN nx_state &lt;= G; ELSE nx_state &lt;= R; END IF; END CASE; END PROCESS com; --**产生次态和输出逻辑的进程**END asm2; 双进程中状态变量要定义为SIGNAL类型，用于进程间信息的传递 可以在产生寄存器的进程中加上异步复位语句，用于确定初始状态: &#96;IF reset&#x3D;‘1’ THEN pr_state &lt;&#x3D; G;&#96;&#96; 注意在组合进程中if语句要写完整if-else 三进程状态机 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152LIBRARY IEEE ;USE IEEE.STD_LOGIC_1164.ALL ;ENTITY traffic IS PORT( clock , timed , car : IN std_ulogic ; start_timer, major_green, minor_green : OUT std_ulogic );END ENTITY traffic ;ARCHITECTURE asm2 OF traffic IS TYPE state_type IS (G, R); --利用枚举类型定义状态 SIGNAL pr_state, next_state : state_type; --将状态机的现态、次态定义为全局信号，便于在进程间传递信息BEGIN seq: PROCESS (clock) BEGIN IF(rising_edge(clock)) THEN pr_state &lt;= next_state;--次态是寄存器的输入 END IF; --条件涵盖不完整的if语句产生状态寄存器 END PROCESS seq; --产生状态寄存器的进程 ns: PROCESS (car, timed, pr_state)BEGIN CASE pr_state IS WHEN G =&gt; IF (car = ‘1’) THEN nx_state &lt;= R; ELSE nx_state &lt;= G; WHEN R =&gt; IF (timed = ‘1’) THEN nx_state &lt;= G; ELSE nx_state &lt;= R; END IF; END CASE; END PROCESS ns; --产生次态逻辑进程 op: PROCESS (car, pr_state) -- Mealy State MachineBEGIN start_timer &lt;= ‘0’; IF (pr_state = G) THEN major_green &lt;= ‘1’; minor_green &lt;= ‘0’; IF (car = ‘1’) THEN start_timer &lt;= ‘1’; END IF; ELSE major_green &lt;= ‘0’; minor_green &lt;= ‘1’; END IF; END PROCESS op;--产生输出逻辑的进程END asm3； 表达方式分类 符号化状态机 在程序的说明部分使用TYPE语句定义枚举类型，其元素用状态机的状态名来定义。状态变量（如状态机的现态和次态）定义为变量或信号，并将状态变量的数据类型定义为含有既定状态元素的枚举类型。多进程时：定义为信号，便于信息的传递。（以上三种进程例子皆是符号化状态机） 类型定义语句：TYPE 数据类型名 IS 数据类型定义 OF 基本数据类型;TYPE 数据类型名 IS 数据类型定义; 确定状态编码状态机 二进制编码格雷码编码one-hot 编码 每一个状态都使用二进制位来编码例：实现4状态的状态机，其其二进制编码可为 状态1&#x3D;“00”状态2&#x3D;“01”状态3&#x3D;“10”状态4&#x3D;“11”需要的寄存器数量最少，有n个寄存器就可以对$2^n$个状态进行编码 格雷码：每次仅有一位发生变化特点：触发器使用较少，速度较慢，不会产生两位同时翻转的情况。当状态位的输出被异步应用时，格雷码编码是有益的。 One-hot 编码：每个状态采用一个触发器进行记录以四个状态为例状态1 “0001” 状态2：”0010“ ….. “0100”. “1000”;特点： 触发器使用较多，逻辑简单、速度快 指明表达方式： 12345678910111213ARCHITECTURE BEHAV OF BINARY ISTYPE STATE_TYPE IS(S1, S2, S3, S4, S5, S6, S7);ATTRIBUTE ENUM_ENCODING: STRING;ATTRIBUTE ENUM_ENCODING OF STATE_TYPE: TYPE IS &quot;001 010 011 100 101 110 111&quot;;-- 换成 one-hot 编码ATTRIBUTE ENUM_ENCODING OF STATE_TYPE: TYPE IS &quot;00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000&quot;; 状态机VHDL举例实现Mealy型状态机 对应的代码： 输出端无同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546LIBRARY ieee;USE ieee.std_logic_1164.all;-----------------------------------------------ENTITY simple_fsm IS PORT (a, b, d, clk, rst: IN BIT; x: OUT BIT);END simple_fsm;-----------------------------------------------ARCHITECTURE simple_fsm OF simple_fsm IS TYPE state IS (stateA, stateB); SIGNAL pr_state, nx_state: state;BEGIN----------Lower section: ---------------------- PROCESS (rst, clk) BEGIN IF (rst = &#x27;1&#x27;) THEN pr_state &lt;= stateA; ELSIF (clk&#x27;EVENT AND clk = &#x27;1&#x27;) THEN pr_state &lt;= nx_state; END IF; END PROCESS;-------------Upper section: -------------------- PROCESS (a, b, d, pr_state) BEGIN CASE pr_state IS WHEN stateA =&gt; x &lt;= a; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= stateB; ELSE nx_state &lt;= stateA; END IF; WHEN stateB =&gt; x &lt;= b; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= stateA; ELSE nx_state &lt;= stateB; END IF; END CASE; END PROCESS;END simple_fsm; RTL图： 输出端有同步 123456789101112131415161718192021222324252627282930313233343536373839404142434445LIBRARY ieee;USE ieee.std_logic_1164.all;-----------------------------------------------ENTITY simple_fsm IS PORT (a, b, d, clk, rst: IN BIT; x: OUT BIT);END simple_fsm;-----------------------------------------------ARCHITECTURE simple_fsm OF simple_fsm IS TYPE state IS (stateA, stateB); SIGNAL pr_state, nx_state: state; SIGNAL temp: BIT := &#x27;0&#x27;; -- 多了这个全局的temp,作为中间变量，在改变状态时进行改变BEGIN----------Lower section: ---------------------- PROCESS (rst, clk) BEGIN IF (rst = &#x27;1&#x27;) THEN pr_state &lt;= stateA; ELSIF (clk&#x27;EVENT AND clk = &#x27;1&#x27;) THEN x &lt;= temp; pr_state &lt;= nx_state; END IF; END PROCESS;-------------Upper section: -------------------- PROCESS (a, b, d, pr_state) BEGIN CASE pr_state IS WHEN stateA =&gt; temp &lt;= a; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= stateB; ELSE nx_state &lt;= stateA; END IF; WHEN stateB =&gt; temp &lt;= b; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= stateA; ELSE nx_state &lt;= stateB; END IF; END CASE; END PROCESS;END simple_fsm; RTL图： 仿真对比：结论： 同步之后（利用temp一起作为输出）同时存储了outputMealy型需要该操作才能设计同步时序电路Moore则不需要 使用三种进程描述状态机单，双，三： 单进程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556LIBRARY IEEE;USE IEEE.STD_LOGIC_1164.ALL;ENTITY s_machine1 IS PORT ( clk, reset : IN STD_LOGIC; state_inputs : IN STD_LOGIC_VECTOR (0 TO 1); comb_outputs : OUT INTEGER RANGE 0 TO 15 );END s_machine2;ARCHITECTURE behv OF s_machine1 IS TYPE FSM_ST IS (s0, s1, s2, s3); SIGnAL state: FSM_ST;BEGIN PROCESS (reset, clk, state, state_inputs) BEGIN IF reset = &#x27;1&#x27; THEN state &lt;= s0; ELSIF clk = &#x27;1&#x27; AND clk&#x27;EVENT THEN CASE state IS WHEN s0 =&gt; comb_outputs &lt;= 5; IF state_inputs = &quot;00&quot; THEN state &lt;= s0; ELSE state &lt;= s1; END IF; WHEN s1 =&gt; comb_outputs &lt;= 8; IF state_inputs = &quot;00&quot; THEN state &lt;= s1; ELSE state &lt;= s2; END IF; WHEN s2 =&gt; comb_outputs &lt;= 12; IF state_inputs = &quot;11&quot; THEN state &lt;= s3; ELSE state &lt;= s0; END IF; WHEN s3 =&gt; comb_outputs &lt;= 14; IF state_inputs = &quot;11&quot; THEN state &lt;= s3; ELSE state &lt;= s0; END IF; END CASE; END IF; END PROCESS;END behv; --（完） (请耐心看完) 双进程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859LIBRARY IEEE;USE IEEE.STD_LOGIC_1164.ALL;ENTITY s_machine IS PORT ( clk, reset : IN STD_LOGIC; state_inputs : IN STD_LOGIC_VECTOR (0 TO 1); comb_outputs : OUT INTEGER RANGE 0 TO 15 );END s_machine;ARCHITECTURE behv OF s_machine IS TYPE FSM_ST IS (s0, s1, s2, s3); SIGNAL current_state, next_state : FSM_ST;--------------------------------BEGIN REG: PROCESS (reset, clk) BEGIN IF reset = &#x27;1&#x27; THEN current_state &lt;= s0; ELSIF clk = &#x27;1&#x27; AND clk&#x27;EVENT THEN current_state &lt;= next_state; END IF; END PROCESS; ------------------------------ COM: PROCESS (current_state, state_inputs) BEGIN CASE current_state IS WHEN s0 =&gt; comb_outputs &lt;= 5; IF state_inputs = &quot;00&quot; THEN next_state &lt;= s0; ELSE next_state &lt;= s1; END IF; WHEN s1 =&gt; comb_outputs &lt;= 8; IF state_inputs = &quot;00&quot; THEN next_state &lt;= s1; ELSE next_state &lt;= s2; END IF; WHEN s2 =&gt; comb_outputs &lt;= 12; IF state_inputs = &quot;11&quot; THEN next_state &lt;= s3; ELSE next_state &lt;= s0; END IF; WHEN s3 =&gt; comb_outputs &lt;= 14; IF state_inputs = &quot;11&quot; THEN next_state &lt;= s3; ELSE next_state &lt;= s0; END IF; END CASE; END PROCESS;END behv; 三进程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172LIBRARY IEEE;USE IEEE.STD_LOGIC_1164.ALL;ENTITY s_machine2 IS PORT ( clk, reset : IN STD_LOGIC; state_inputs : IN STD_LOGIC_VECTOR (0 TO 1); comb_outputs : OUT INTEGER RANGE 0 TO 15 );END s_machine2;ARCHITECTURE behv OF s_machine2 IS TYPE FSM_ST IS (s0, s1, s2, s3); SIGNAL current_state, next_state: FSM_ST;BEGIN REG: PROCESS (reset, clk) BEGIN IF reset = &#x27;1&#x27; THEN current_state &lt;= s0; ELSIF clk = &#x27;1&#x27; AND clk&#x27;EVENT THEN current_state &lt;= next_state; END IF; END PROCESS;--状态逻辑------------------------------------------------------ COM_STATE: PROCESS(current_state, state_inputs) BEGIN CASE current_state IS WHEN s0 =&gt; IF state_inputs = &quot;00&quot; THEN next_state &lt;= s0; ELSE next_state &lt;= s1; END IF; WHEN s1 =&gt; IF state_inputs = &quot;01&quot; THEN next_state &lt;= s1; ELSE next_state &lt;= s2; END IF; WHEN s2 =&gt; IF state_inputs = &quot;10&quot; THEN next_state &lt;= s3; ELSE next_state &lt;= s0; END IF; WHEN s3 =&gt; IF state_inputs = &quot;11&quot; THEN next_state &lt;= s3; ELSE next_state &lt;= s0; END IF; END CASE; END PROCESS; --- 次态逻辑--------------------------------------------- COM_OUT: PROCESS (current_state) BEGIN CASE current_state IS WHEN s0 =&gt; comb_outputs &lt;= 5; WHEN s1 =&gt; comb_outputs &lt;= 8; WHEN s2 =&gt; comb_outputs &lt;= 12; WHEN s3 =&gt; comb_outputs &lt;= 14; END CASE; END PROCESS;END behv;-- 输出逻辑 单进程描述的状态机的RTL电路相较于两外两种多了一个 寄存器而 双进程与三进程则对于简单的设计一样（更为建议） 串流数据流检测器设计一个串行数据流检测器。要求：输入连续的二进制数，当检测到连续“1”的个数大于3个的时候，输出“1”；其他状态输出“0”。 分析：确定所需的状态数，取决于数据流中出现连续“1”的个数，应该为4个状态。 画出ASM图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859LIBRARY ieee;USE ieee.std_logic_1164.all;----------------------------------------ENTITY string_detector IS PORT (d, clk, rst: IN BIT; q: OUT BIT);END string_detector;---------------------------------------ARCHITECTURE my_arch OF string_detector IS TYPE state IS (zero, one ,two, three); SIGNAL pr_state, nx_state: state;BEGIN -----------Lower section;----------- PROCESS (rst, clk) BEGIN IF (rst = &#x27;1&#x27;) THEN pr_state &lt;= zero; ELSIF (clk&#x27;EVENT AND clk = &#x27;1&#x27;) THEN pr_state &lt;= nx_state; END IF; END PROCESS; -----------Upper section:------------ PROCESS (d, pr_state) BEGIN CASE pr_state IS WHEN zero =&gt; q &lt;= &#x27;0&#x27;; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= one; ELSE nx_state &lt;= zero; END IF; WHEN one =&gt; q &lt;= &#x27;0&#x27;; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= two; ELSE nx_state &lt;= zero; END IF; WHEN two =&gt; q &lt;= &#x27;0&#x27;; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= three; ELSE nx_state &lt;= zero; END IF; WHEN three =&gt; q &lt;= &#x27;1&#x27;; IF (d = &#x27;1&#x27;) THEN nx_state &lt;= three; ELSE nx_state &lt;= zero; END IF; END CASE; END PROCESS;END my_arch; 综合后是 使用的one-hot 编码如果需要指定编码则可以使用attribute语句将结构体的声明部分添加如下代码 123ATTRIBUTE enum_encoding: string;ATTRIBUTE enum_encoding OF state : TYPE IS &quot;00 01 10 11&quot;; 软件设置： FSM Explorer 选项勾选，综合后也是one-hot编码","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第四章时序逻辑电路","slug":"VHDL第四章时序逻辑电路","date":"2023-02-15T08:35:50.000Z","updated":"2023-02-15T08:36:18.760Z","comments":true,"path":"2023/02/15/VHDL第四章时序逻辑电路/","link":"","permalink":"http://example.com/2023/02/15/VHDL%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","excerpt":"","text":"输出不仅与当前输入有关，还与原始状态有关 组合逻辑电路+ 存储电路（包含有 触发器，寄存器等） 锁存器 触发器 寄存器 计数器 乘法器时序电路引进了 现态和次态的概念可以使用逻辑表达式来进行描述 #分类 按照触发器（动作特点） 同步时序逻辑电路，同一个时钟信号。 异步时序逻辑电路，没有统一的时钟脉冲信号，触发器的变化有前有后。 按照输出信号的特点 米丽（Mealy）输入状态不仅与存储电路状态Q有关，并且与外部输入X有关。 摩尔（Moore）输出状态仅与存储电路的状态Q有关 无关输入X。 时序逻辑电路——锁存器 RS锁存器根据真值表来进行判断 S R Q ~Q 0 0 1 1 0 1 0 1 1 0 1 0 1 1 Q ~Q 123456789101112131415161718192021Library ieee;Use ieee.std_logic_1164.all;Entity SR_latch2 is port ( S, R: in std_logic ; Q, Qbar :out std_logic);End SR_latch2;Architecture behav of R_latch2 isBegin process ( R , S ) is variable rs: std_logic_vector(1 downto 0);begin rs:=R&amp;S; case rs is when &quot;00&quot; =&gt; Q&lt;=&#x27;1&#x27;; Qbar&lt;=&#x27;1&#x27;; when &quot;01&quot; =&gt; Q&lt;=&#x27;1&#x27;; Qbar&lt;=&#x27;0&#x27;; when &quot;10&quot; =&gt; Q&lt;=&#x27;0&#x27;; Qbar&lt;=&#x27;1&#x27;; when others=&gt;null; end case; end process;end behav;--敏感参数有R和S D锁存器D锁存器通过条件涵盖不完整的if语句 产生寄存器；#值得一看敏感参数表包含D、Enable，综合后 形成一个电平触发的锁存器 123456789101112131415Library ieee;Use ieee.std_logic_1164.all;Entity D_latch is port ( D, Enable: in std_logic ; Q: out std_logic );End D_latch;Architecture behav of D_latch isBegin process(D, Enable) begin if (Enable=‘1’) then Q&lt;=D; end if; end process;End behav; 触发器触发器是指边沿触发的寄存器，常见的有D型，JK型，T型。在描述触发器前要注意时钟上升沿的描述 D触发器一个D 一个Clock输出一个Q 12345678910111213141516171819202122232425library ieee;use ieee.std_logic_1164.all;entity d_ff1 is port(D,clk: in std_logic; Q:out std_logic);end d_ff1;architecture behav of d_ff1 isbegin process(clk) begin if(clk&#x27; event and clk = &#x27;1&#x27;) then Q&lt;=D; end if ; end process;end behav;---第二种方式 process begin wait until (clk=‘1’) ; --等同于 wait until clk’event and clk=‘1’； Q&lt;=D; end process;End behav; 时钟边沿检测到的方法 #值得一看 上升沿：clock’ event and clock&#x3D;‘1’下降沿：clock’ event and clock&#x3D;‘0’; 利用WAIT语句启动进程，检测colck的上升沿 Process 和 if语句的相结合 利用clk启动进程，并进行判断 带Q非的D触发器不是简单的按照前面直接加上一个Qbar如Qbar = NOT D时钟上升沿会有两个赋值，导致有两个D触发器 解决方式 信号法： 12345678910111213141516architecture sig of D_ff is signal state: std_logic;begin process(clock, reset) begin if(reset=&#x27;0&#x27;)then state&lt;=&#x27;0&#x27; else if rising_edge(clock) then state&lt;=D; end if; end process; Q&lt;=state; Qbar&lt;=not state;end sig;--利用信号作为中间变量，D触发器 变量法： 123456789101112131415Architecture var of D_FF is Begin process(clock, reset) variable state: std_logic ; begin if (reset=‘0’) then state:=‘0’; elsif rising_edge(clock) then state:=D; end if; Q&lt;=state; Qbar&lt;=not state; end process;End var;--跟变量法相似，只是state的范围限定在process内 JK触发器四个输入J K R（reset） Clock 两个输出 Q Qbar J K Q Qbar 0 0 Q Qbar 0 1 0 1 1 0 1 0 1 1 Qbar Q 12345678910111213141516171819202122232425entity JK_ff is port(J,K: in std_logic; clock,reset: in std_logic; Q, Qbar: out std_logic);end JK_ff;architecture behav of JK_ff issignal state:std_logic;begin process( clock, reset) is variable jk: std_logic_vector(1 downto 0); begin jk:=J&amp;K; if (reset=‘0’) then state&lt;=‘0’; elsif rising_edge(clock) then case jk is when “11”=&gt; state&lt;=not state; when “10”=&gt; state&lt;=‘1’; when “01”=&gt; state&lt;=‘0’; when others =&gt; null; end case; end if;end process; Q&lt;=state; Qbar&lt;=not state ;end behav **CASE语句要完整,所以在CASE JK的时候要加when others &#x3D;&gt;null; T触发器 1234567891011121314151617181920Entity T_FF is port ( T, clock, reset : in std_logic ; Q, Qbar : out std_logic );End T_FF;Architecture behav of T_FF isBegin process(clock, reset) variable state: std_logic ; begin if (reset =‘0’) then state:=‘0’; elsif rising_edge(clock) then if T=‘1’then state := not state; end if; end if ; Q&lt;=state; Qbar&lt;= not state; end process;End behav ; 寄存器的设计一个D触发器就是一个寄存器，多位可以由多个D触发器构成 1234567891011121314151617Entity reg is generic( n: natural :=4 ); --实体类属中的常数 port ( D: in std_logic_vector(n-1 downto 0); clock, reset : in std_logic; Q: out std_logic_vector (n-1 downto 0) );End reg ;Architecture behav of reg isBegin process(clock, reset) begin if (reset=‘0’) then Q&lt;=( others=&gt;‘0’); --表示Q赋全‘0’ elsif rising_edge(clock) then Q&lt;=D; end if; end process;End behav ; 移位寄存器 1234567891011121314151617181920Entity sipo is generic( n : natural :=8); port ( a : in std_logic ; q: out std_logic_vector(n-1 downto 0); clk : in std_logic );End sipo;Architecture behav of sipo isBegin process(clk) variable reg : std_logic_vector(n-1 downto 0); begin if rising_edge(clk) then reg : = reg ( n-2 downto 0) &amp; a ; --左移移位寄存器； -- reg : = a &amp; reg (n-1 downto 1); 右移移位寄存器 end if ; q&lt;= reg ; end process;End behav; 计数器用“+”函数描述 12345678910111213141516171819202122232425Library ieee ;Use ieee.std_logic_1164.all;Use ieee.std_logic_unsigned.all;Entity counter is generic( n: natural :=4); port ( clk : in std_logic; reset : in std_logic ; count : out std_logic_vector(n-1 downto 0) );End counter;architecture ripple of counter is component T_FF is port( T: in std_logic ; clk:in std_logic; reset:in std_logic; Q : out std_logic; Qbar:out std_logic); end component ; --将前面描述好的T触发器定义为元件； signal carry: std_logic_vector( n downto 0);Begin carry(0)&lt;=clk; g0: for i in 0 to n-1 generate --循环 T1: T_FF port map ( ‘1’, carry( i ), reset, count( i ), carry( i+1 ) ); end generate g0;End ripple ; 波形仿真： 总结","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第三章组合逻辑电路","slug":"VHDL第三章组合逻辑电路","date":"2023-02-15T08:34:19.000Z","updated":"2023-02-15T08:35:26.934Z","comments":true,"path":"2023/02/15/VHDL第三章组合逻辑电路/","link":"","permalink":"http://example.com/2023/02/15/VHDL%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/","excerpt":"","text":"数字电路按照完成逻辑功能的不同特点， 组合逻辑电路 任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关 电路没有记忆功能 电路结构上不存在反馈路径 常见的有简单门电路，选择器，译码器，三态门 时序逻辑电路 任意时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态，或者说，还与以前的输入有关。 设计方法使用可编程逻辑器件，用硬件语言描述的EDA设计方法（1）逻辑问题的描述。将设计问题转化为一个逻辑问题（2）根据逻辑问题，用硬件描述语言进行描述（3）对描述进行综合，仿真测试（4）生成最终网表，下载到芯片 描述方法 数据流描述： 并行语句 结构 ：组件和互连 行为(时序)：顺序语句 寄存器 状态机 指令解码 VHDL 数据流设计风格可以变成 VHDL 代码，反之不可行 并行信号赋值（&lt;&#x3D;) 条件并行信号赋值（when -else) 选择并行信号赋值（with-select-when） for generate 注意优先级 y &lt;= (a and b) or (c and d) ;同一个信号不能出现在并行赋值语句的两边 也就是&lt;&#x3D; 门电路四种基本操作：与，或，非，，触发器操作，以与非门为例 1234567891011library ieee;use ieee.std_logic_1164.all;entity nand2 is port (a,b: in std_logic; y: out std_logic);end nand2;architecture behav of nand2 isbegin y &lt;= a nand b;end behav;-- 如果吧nand变为nor就是或非 译码器输入为二进制代码，输出是一组高低电平信号变量码制变换显示译码~ 地址译码~ 以3-8译码器为例3个输入端 abc,。 g1,g2a,g2b为选择信号当g1 &#x3D;’1’, ‘0’’0’为例，正常工作 1234567891011121314151617181920212223library ieee;use ieee.std_logic_1164.all;entity decoder is port (a,b,c,g1,g2a,g2b: in std_logic; y: out std_logic_vector(7 downto 0);end decoder;architecture behav of decoder issignal indata: std_logic_vector(2 downto 0);begin indata &lt;= c&amp;b&amp;a; process(indata,g1,g2a,g2b) begin if (g1=&#x27;1&#x27; and g2a = &#x27;0&#x27;and g2b = &#x27;0&#x27;) then case indata is when &quot;000&quot; =&gt; y &lt;=&quot;11111110&quot;; when /.... .... end case; else y&lt;= &quot;11111111&quot;; end if; end process;end behav; 编码器它的输入是一组高低电平信号，输出是一组二进制代码优先级编码器74ls1483位二进制码输出的优先级编码当有多个输入时，有优先级 12345678910111213141516171819202122Library IEEE;Use IEEE.std_logic_1164.all;Entity priorityencoder is Port ( input : in std_logic_vector (7 downto 0 ); y: out std_logic_vector( 2 downto 0) );End priorityencoder;Architecture behav of priorityencoder isBegin Process(input) Begin If ( input(0)=‘0’) then y&lt;=“111”; elsif ( input(1)=‘0’) then y&lt;=“110”; elsif ( input(2)=‘0’) then y&lt;=“101”; elsif ( input(3)=‘0’) then y&lt;=“100”; elsif ( input(4)=‘0’) then y&lt;=“011”; elsif ( input(5)=‘0’) then y&lt;=“010”; elsif ( input(6)=‘0’) then y&lt;=“001”; elsif ( input(7)=‘0’) then y&lt;=“000”; else y&lt;=“XXX”; end if; End process;End behav; #值得一看 加法器半加 全加（有进位）前者两个输入，两个输出后者三个输入，两个输出 12345678910111213LIBRARY ieee;USE ieee.std_logic_1164.all;ENTITY full_add ISPORT ( X,Y,Z:in bit; Sum,Carry:out bit);END full_add;ARCHITECTURE a OF full_add ISBEGIN Sum &lt;= X xor Y xor Z; Carry&lt;=(X and Y) or (Y and Z) or (Z and X);END a; -- 对于这些操作可以看真值表 #模块化处理 12345678library ieee;use ieee.std_logic_1164.allpackage components is COMPONENTS fadd is port(a,b,ci: in std_logic; co,sum:out std_logic); end fadd;end components; 三态门12345678910111213141516Library IEEE;Use IEEE.std_logic_1164.all;Entity tri_gate is port ( din , en : in std_logic; dout : out std_logic );End tri_gate ;Architecture behav of tri_gate isBegin process ( din ,en) begin if (en=‘1’) then dout&lt;=din; else dout&lt;=‘Z’; end if ; end process; End behav; 缓冲器缓冲寄存器，在总线传输中起数据暂存缓冲输入缓冲，输出缓冲单向与双向之分 1234567891011121314151617181920212223242526272829Library IEEE;Use IEEE.std_logic_1164.all;Entity tri_bigate is port ( a , b: inout std_logic_vector(7 downto 0) ; en , dr : in std_logic );End tri_bigate ;Architecture behav of tri_bigate is signal aout , bout :std_logic_vector ( 7 downto 0 );Begin process ( a , dr , en) begin if ( (en=‘0’) and ( dr=‘1’) ) then bout&lt;=a; else bout&lt;=“ZZZZZZZZ”; end if ; b&lt;=bout ; end process; process ( b , dr , en) begin if ( (en=‘0’) and ( dr=‘0’) ) then aout&lt;=b; else aout&lt;=“ZZZZZZZZ”; end if ; a&lt;=aout ; end process; End behav;","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"VHDL第二章语法基础","slug":"VHDL第二章语法基础","date":"2023-02-15T08:33:03.000Z","updated":"2023-02-15T08:33:51.125Z","comments":true,"path":"2023/02/15/VHDL第二章语法基础/","link":"","permalink":"http://example.com/2023/02/15/VHDL%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Very-High-Speed Integrated circuit Hardware Description Language 用途 主要用于描述字系统的结构、行为、功能和接口VHDL侧重于系统描述，更适合系统级设计 具有 硬件特征，并且是并行执行方式 基本结构 库的调用 ——相当于操作系统中的目录 程序包的调用 —— 类似于include 实体说明—— 用于说明设计系统的外部接口信息 结构体 —— 描述行为 VHDL的主要构件 基本构件：库、包、配置、实体、结构体、块、子程序（函数以及过程） 主要构件：库 程序包 实体 结构体1print (hello) 库： LIBRARY + 库名 库(Library)是编译后数据的集合，是存放预先完成的程序包和数据集合体的仓库。 std库 IEEE库，work库（默认库）。面向asic的库，哈hi有自定义的库 123LIBRARY IEEE;USE IEEE.std_logic_1164.ALL;;USE IEEE.std_logic_unsigned.ALL; 一般使用的是IEEE库，有四个常用的程序包 std_logic_1164 std_logic_arith std_logic_signed std_logic_unsigned 包1USE IEEE.STD_LOGIC_1164.ALL 不同的包，一样的语句会产生不同的形式的结果 实体包括实体名，类属参数说明，端口说明由”ENTITY” 引导 1234ENTITY 实体名 IS [类属参数说明]； [端口说明]；END [ENTITY] [实体名]； 以END ENTITY 结尾 类属参数说明 说明静态信息&#96;GENERIC (常数名：数据类型: &#x3D;设定值)1GENERIC(m:time:= 1ns); 端口说明提供外部接口信息PORT (端口名：端口方向 数据类型）1PORT(d0:IN std_logic) 例子 结构体ARCHITECTURE 设计实体的具体描述，指明具体行为，两部分 定义说明和具体功能描述 12345678910ARCHITECTURE 结构体 OF 实体名 IS[定义语句] 信号 (signal); 常数 (constant); 数据类型(type); 函数(function); 原件(component);BEGIN [并行处理语句]；END 结构体名； 语句并行结构体的描述方法： 行为描述、数据流描述、结构描述 配置描述层与层之间的连接关系和实体和结构体之间的连接关系 123CONFIGURATION 配置名 OF 实体名 IS [语句说明];END 配置名; 作用：利用配置语句来选择不同的结构体 数据类型以及运算符10种标准数据类型还有用途 还由用户自定义的数据类型 123TYPE 数据类型名 IS 数据类型定义 OF 基本数据类型或 TYPE 数据类型名 IS 数据类型定义 常用的有 枚举类型， 子类型 整数类型和实数类型 1TYPE week IS (sum, mon, tue, wed, thu, tri, sat); --枚举类型 12SUBTYPE natural IS integer range 0 to integer’high--子类型 1234567891011TYPE percent IS INTEGER RANGE -100 TO 100-- 整数类型和实数类型TYPE 数组名 IS ARRAY(数组范围) OF 数组类型；数组类型TYPE 记录类型名 IS RECORD 元素名：元素数据类型； 元素名: 元素数据类型：END RECORD;-- 记录类型 数据类型转换std_logic_1164: TO_STDLOGICVECTOR(A) –&gt; 由 BIT_VECTOR 转换为STD_LOGIC_VECTOR TO_BITVECTOR(A) –&gt;BIT转到bitvector() TO_STDLOGIC(A) –&gt;由BIT转 换STD_LOGIC TOBIT(A) std_logic_arich: CONV_STD_LOGIC_VECTOR(A,n)(n为位长) integer unsigned signed 转换为std_logic_vector CONV_INTEGER(A) unsigned signed 转换为integer std_logic_unsigned: conv_integer(A) ,std_logic_vector转换为integer 运算符 数据对象可以赋值的都叫做 对象 常量：设计中不变的值 变量 ： 定义在进程中或子程序种的变化量 对应硬件内部实实在在的连线 12345CONSTANT 常数名：数据类型：=表达式 CONSTANT fbus:bit_vector:=“0101”--总线上的数据向量 全局的量 1234VARIABLE 变量名：数据类型:= 初始值VARIABLE time:integer RANGE 0 TO 6 --进程中代表次数的变化 局部量对变量的赋值是立即生效的 1SIGNAL 信号名:数据类型:=表达式 “:&#x3D;”表示对信号的赋初值，一般不产生延时。“&lt;&#x3D;”表示信号的代入赋值，有延时。 信号赋值有延迟；而变量赋值没有延迟。 进程对信号敏感，对变量不敏感。信号可以是多个进程的全局信号, 而变量只在定义它的进程中可见 在描述中，信号的赋值不会立即生效，而是要等待一个delta延迟后才会变化，否则该信号的值在delta延迟之前仍是原来的值。 变量存储临时数据 保存中间结果(：&#x3D; ）赋值立即发生，进程内有效常量用于保存静态数据信号有延时（&lt;&#x3D;) 跨进程 基本语句具有顺序和并行语句（特点顺序语句需要用process进行封装“–”表示注释 并行语句包括7种语句 赋值语句 条件赋值语句、 选择信号赋值语句、 进程语句 元件例化语句 生成语句 子程序调用语句 赋值语句 信号 &lt;&#x3D;变量和常量 :&#x3D; 条件赋值语句a &lt;&#x3D; 表达式1 when 条件 else 表达式2 when 条件 else … 表达式n； 只有最后一句需要分号 选择信号赋值逗号和分号的作用情况with instrution selecta &lt;&#x3D; b when “100”,…‘Z’ when others; 进程语句process本身就是一个并行语句，内部是顺序语句 启动方式有两种：敏感参数以及wait语句 敏感参数： process(参数) 只要参数一变化，process就会启动 wait语句：processbegin output &lt;&#x3D; in1 OR in2; wait on in1,in2;END PROCESS; 等待in1, in2信号发生变化，进程再次执行 进程的启动只能是信号敏感参数以及wait 语句不能混用当一个进程执行结束后，先挂起来，直到有新的启动信号变化为止 元件例化语句 生成语句有IF 和FOR来控制的 子程序调用语句子程序调用 ：过程调用语句和函数调用 顺序语句 IF语句 可以和 when else 互换 123IF reset=‘0’ THEN q&lt;=‘0’;ELSIF ‘clk’ event AND clk=‘1’ THEN q&lt;=d; END IF; CASE语句 可以和 with else语句互换 12345678CASE sel IS WHEN 0=&gt; y&lt;=d0； WHEN 1=&gt; y&lt;=d1； WHEN OTHERS&lt;=NULL;END CASE LOOP语句 EXIT 和 NEXT语句（loop内部的循环控制语句） 其他顺序语句 wait语句wait on 信号表wait until 条件表达式wait for 时间表达式 返回语句RETURN仅用于子程序 空操作语句NULL常用于CASE语句中 属性描述语句具有属性的项目有很多： 类型，子类型，过程，函数，信号，变量，常量，实体，结构体，配置，程序包，元件和语句标号等，属性是这些项目的特性 预定义描述语句格式：属性对象’属性名 1.信号类属性EVENT表示信号发生率动作，stable表示无事件发生 123456NOT clock`STABLE AND clock = &#x27;1&#x27;; --检测时钟上升沿clock`EVENT AND clock=&#x27;1&#x27;; --检测时钟上升沿还有 s`delayed(time)s&#x27;stables&#x27;quiet(time) 2. 数值区间类属性RANGE和REVERSE_RANGE 3. 数值类属性.LEFT &#39;RIGHT HIGH LOW之类 4. 数组属性’LENGTH 对宽度进行获取 5. 用户自定义的属性ATTRIBUTE 属性名 OF 对象名：对象类型 IS 值 其他构建 块是一种划分 ，不影响综合，将模块划分为数个区域 函数 &#96;&#96;&#96; FUNCTION 函数名（参数表）RETURN 数据类型； FUNCTION 函数名（参数表）RETURN 数据类型 IS [说明部分]； [说明部分]； BEGIN 顺序语句； END 函数名； &#96;&#96;&#96; 过程 PROCEDURE 和函数一样 两部分组成 过程首和过程体 函数和过程都是顺序语句，并且不能说明信号过程参数表一般要定义参量的流向模式，如果没有指定默认为IN过程中可以有WAIT语句（但综合器一般不支持），函数中能过程有多个返回值，函数只有一个 还有程序包示例： 还有TEXTIO构件","categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"}]},{"title":"通原笔记_1（1至2章）","slug":"通原笔记-1","date":"2023-01-24T15:42:26.000Z","updated":"2023-01-24T15:59:52.914Z","comments":true,"path":"2023/01/24/通原笔记-1/","link":"","permalink":"http://example.com/2023/01/24/%E9%80%9A%E5%8E%9F%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"​ 最近愈发觉得在蹉跎时间，也稍微把游戏放一放，现在更能感受到人的“温度”，而不是打完游戏之后的一身虚无以及疲惫、无知。 选择西安电子科技大学通信原理观看，也把之前很多不懂的地方重新认识了一遍，借此文来记录笔记。 第一章","categories":[],"tags":[{"name":"通信原理 笔记","slug":"通信原理-笔记","permalink":"http://example.com/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86-%E7%AC%94%E8%AE%B0/"}]},{"title":"初晴","slug":"初晴","date":"2023-01-14T15:45:42.000Z","updated":"2023-01-15T08:56:01.213Z","comments":true,"path":"2023/01/14/初晴/","link":"","permalink":"http://example.com/2023/01/14/%E5%88%9D%E6%99%B4/","excerpt":"","text":"​ 下了两天的小雨，地上，墙上都是湿漉漉的，没想到下午的开始放晴了。雨后初晴，天实在是很干净。就好像在一块蓝色的幕布上撒下了这些云彩一般，望向天空，注意力很难不被这些”小可爱”所吸引，看着它，仿佛有摄人心魄的能力，仿佛心也随之飘荡在蓝天之上没一下子就开阔起来。 这是附近的基站，从小时候便有了，距今好像也有近乎十年的历史了，仍然矗立在那，配上背后的云彩，便有了一种独特，我难以描述的美感。 这两张照片是在田地里拍摄的，当时的天空还有太阳在照着，但慢慢的，便被这片云藏了起来。站在广阔的田里，抬头便是这篇云，细看其中，有种漫威电影里的混沌的感觉，觉得颇为有趣","categories":[],"tags":[{"name":"风景 感悟","slug":"风景-感悟","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF-%E6%84%9F%E6%82%9F/"}]},{"title":"勇气","slug":"勇气","date":"2023-01-12T14:30:37.000Z","updated":"2023-01-13T16:08:38.320Z","comments":true,"path":"2023/01/12/勇气/","link":"","permalink":"http://example.com/2023/01/12/%E5%8B%87%E6%B0%94/","excerpt":"","text":"​ 《被讨厌的勇气》 《月光落在左手上》 ​ 今天又重拾起一本曾经读过的书，虽然读过，但只是浅浅的读了一遍，受益匪浅，但是对于现在的我来说仍然有很多未解之谜。最近这两年来，也发现自己有暴躁的倾向，内心也时常久久不能平静，便萌生了再读一遍的想法。至于第二本书，余秀华女士的诗歌，或许也能打开我的一扇新世界的大门。 ​ 被讨厌的勇气 开篇的两句话便可见这本书对于很多人都有很大的作用 ​ 月光落在左手上 诗的名字：我爱你，巴巴的活着，这何尝不是大部分人的写照呢，机械般的活着。把自己比喻作陈皮，在阳光下才能舒展开来，不同的茶叶便能带来心中的美好，平平淡淡的生活中，都有让自己开心的事物存在，但是诗人自身的不幸，痛苦在这个时候又将其拉回现实，这便是内心的雪。诗人表示自己并不会这么容易肝肠寸断，因为诗人把自己比作那稗子一样，长在稻谷周围，很相似，但是却并不是那稻子，只是一种极其不受欢迎的野草。诗人在庭院之中读着心爱之人的诗歌，以突然飞过的麻雀儿寓意时光的飞逝。稻子和稗子都渴望春天，但是稗子的渴望中又带着“提心吊胆”。一不小心便会失去。 就连耶稣用稗子设过比喻：“天国，好像人撒好种子在田里。有仇敌来，将稗子撒在麦子里，就走了。好种就是天国之子。稗子就是那恶者之子。撒稗子的仇敌就是魔鬼。收割的时候就是世界的末了。”Link 所以便有了：活为稗子，提心吊胆。","categories":[],"tags":[{"name":"被讨厌的勇气 读书 月光落在左手上","slug":"被讨厌的勇气-读书-月光落在左手上","permalink":"http://example.com/tags/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94-%E8%AF%BB%E4%B9%A6-%E6%9C%88%E5%85%89%E8%90%BD%E5%9C%A8%E5%B7%A6%E6%89%8B%E4%B8%8A/"}]},{"title":"Special page","slug":"Special-page","date":"2023-01-11T14:02:02.000Z","updated":"2023-01-15T09:01:59.315Z","comments":true,"path":"2023/01/11/Special-page/","link":"","permalink":"http://example.com/2023/01/11/Special-page/","excerpt":"","text":"For Lady Shen，我最喜欢的人，当你看到这个网页，我想应该已经是比较晚的时候了，现在是2022年的11月18号，23点21分 ​ 先草率的看一下，以后想说的话，都会在这里的喜欢你，每一天爱你，每一天晚安 现在是19号的0:14分 可能我真的不适合谈恋爱吧，一边说喜欢，一边表现出来却又并没有像我所说的那么喜欢。或许这才是现在的我吧。 -&gt; -&gt; -&gt; -&gt; -&gt; -&gt;可能真的到结尾了吧。 The story never endshahaha，并没有到结尾，因为才刚刚开始，好多事还没来得及去说，还没有牵过手，还没有一起去看过电影，去逛过公园，还没有去到以后的以后所以，哪有那么容易结束呢，以前都没有想过会像现在这样有着另一个人的陪伴和关心，我越去思考，越会觉得不可思议，从相遇到现在的相恋，或许每一步都是注定的吧，是一份来自上天的礼物，奖励我单身20年的一份礼物。 又到了假期，现在的假期长了许多，多了一个月，但同时也多了许多未完成的考试，有好的方面也有坏的方面，但是又如何呢，人嘛，还是要懂得趋利避害的，对事情分析要冷静需要明白自己做的事是为了什么，有“勇气”去进行下一步的动作，这里的勇气二字，主要来源于《被讨厌的勇气》，我拜读过一遍，当时如饥似渴的读，只懂了很浅的表面，现在也该开启新的篇章了再去读一遍，把书读薄，也该把《撒哈拉的故事》读一遍，体会到荷西与三毛的那份感情，三毛对于生活的态度。尝试让自己丰富起来 “总有一阵风会吹过我再吹过你，总有一个瞬间我们之间的距离是零” ————————我们需要的“眼睛为她下着雨，心里却为她打着伞，这就是爱情” ———————— 泰戈尔 “其实最棒的回忆就在当下，在眼前，而且这会是人生最美好的时光” ————————偷影子的人 最近这几天觉得真的好开心呀，真的到了一个新的阶段，相互关心，相互需要，相互依偎，更应该珍惜现在的美好事物，不过最近也有点情绪波动就是说，玩游戏玩得多容易被干扰，关键的还是我的心灵好像逐渐贫瘠了，变得干涸起来了，没有书的涵养，腹有诗书气自华是真实存在的，多读书，改变自己的想法，也尝试去做的更好。（2022-12-11 23:19）","categories":[],"tags":[]},{"title":"test","slug":"test","date":"2023-01-05T08:38:09.000Z","updated":"2023-01-05T08:48:07.445Z","comments":true,"path":"2023/01/05/test/","link":"","permalink":"http://example.com/2023/01/05/test/","excerpt":"","text":"hello, my beloved lady.小申","categories":[],"tags":[]},{"title":"test_my_site","slug":"test-my-site","date":"2023-01-04T16:20:22.000Z","updated":"2023-01-04T16:20:22.662Z","comments":true,"path":"2023/01/05/test-my-site/","link":"","permalink":"http://example.com/2023/01/05/test-my-site/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"VHDL 学习","slug":"VHDL-学习","permalink":"http://example.com/tags/VHDL-%E5%AD%A6%E4%B9%A0/"},{"name":"通信原理 笔记","slug":"通信原理-笔记","permalink":"http://example.com/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86-%E7%AC%94%E8%AE%B0/"},{"name":"风景 感悟","slug":"风景-感悟","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF-%E6%84%9F%E6%82%9F/"},{"name":"被讨厌的勇气 读书 月光落在左手上","slug":"被讨厌的勇气-读书-月光落在左手上","permalink":"http://example.com/tags/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94-%E8%AF%BB%E4%B9%A6-%E6%9C%88%E5%85%89%E8%90%BD%E5%9C%A8%E5%B7%A6%E6%89%8B%E4%B8%8A/"}]}